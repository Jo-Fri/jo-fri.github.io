<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive BOM for KiCAD</title>
    <style type="text/css">
         :root {
            --pcb-edge-color: black;
            --pad-color: #878787;
            --pad-color-highlight: #D04040;
            --pin1-outline-color: #ffb629;
            --pin1-outline-color-highlight: #b4ff03;
            --silkscreen-edge-color: #aa4;
            --silkscreen-polygon-color: #4aa;
            --silkscreen-text-color: #4aa;
            --fabrication-edge-color: #907651;
            --fabrication-polygon-color: #907651;
            --fabrication-text-color: #a27c24;
            --track-color: #def5f1;
            --track-color-highlight: #D04040;
            --zone-color: #def5f1;
            --zone-color-highlight: #d0404080;
        }
        
        html,
        body {
            margin-left: 0px;
            margin-right: 0px;
            margin-top: 0px;
            margin-bottom: 0px;
            height: 100%;
            font-family: Verdana, sans-serif;
            padding-left: 10px;
            padding-right: 10px;
            padding-top: 0px;
            padding-bottom: 0px;
        }
        
        .dark.topmostdiv {
            --pcb-edge-color: #eee;
            --pad-color: #808080;
            --pin1-outline-color: #ffa800;
            --pin1-outline-color-highlight: #ccff00;
            --track-color: #42524f;
            --zone-color: #42524f;
            background-color: #252c30;
            color: #eee;
        }
        
        button {
            background-color: #eee;
            border: 1px solid #888;
            color: black;
            height: 44px;
            width: 44px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            font-weight: bolder;
        }
        
        .dark button {
            /* This will be inverted */
            background-color: #c3b7b5;
        }
        
        button.depressed {
            background-color: #0a0;
            color: white;
        }
        
        .dark button.depressed {
            /* This will be inverted */
            background-color: #b3b;
        }
        
        button:focus {
            outline: 0;
        }
        
        button#tb-btn {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8.47 8.47'%3E%3Crect transform='translate(0 -288.53)' ry='1.17' y='288.8' x='.27' height='7.94' width='7.94' fill='%23f9f9f9'/%3E%3Cg transform='translate(0 -288.53)'%3E%3Crect width='7.94' height='7.94' x='.27' y='288.8' ry='1.17' fill='none' stroke='%23000' stroke-width='.4' stroke-linejoin='round'/%3E%3Cpath d='M1.32 290.12h5.82M1.32 291.45h5.82' fill='none' stroke='%23000' stroke-width='.4'/%3E%3Cpath d='M4.37 292.5v4.23M.26 292.63H8.2' fill='none' stroke='%23000' stroke-width='.3'/%3E%3Ctext font-weight='700' font-size='3.17' font-family='sans-serif'%3E%3Ctspan x='1.35' y='295.73'%3EF%3C/tspan%3E%3Ctspan x='5.03' y='295.68'%3EB%3C/tspan%3E%3C/text%3E%3C/g%3E%3C/svg%3E%0A");
        }
        
        button#lr-btn {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8.47 8.47'%3E%3Crect transform='translate(0 -288.53)' ry='1.17' y='288.8' x='.27' height='7.94' width='7.94' fill='%23f9f9f9'/%3E%3Cg transform='translate(0 -288.53)'%3E%3Crect width='7.94' height='7.94' x='.27' y='288.8' ry='1.17' fill='none' stroke='%23000' stroke-width='.4' stroke-linejoin='round'/%3E%3Cpath d='M1.06 290.12H3.7m-2.64 1.33H3.7m-2.64 1.32H3.7m-2.64 1.3H3.7m-2.64 1.33H3.7' fill='none' stroke='%23000' stroke-width='.4'/%3E%3Cpath d='M4.37 288.8v7.94m0-4.11h3.96' fill='none' stroke='%23000' stroke-width='.3'/%3E%3Ctext font-weight='700' font-size='3.17' font-family='sans-serif'%3E%3Ctspan x='5.11' y='291.96'%3EF%3C/tspan%3E%3Ctspan x='5.03' y='295.68'%3EB%3C/tspan%3E%3C/text%3E%3C/g%3E%3C/svg%3E%0A");
        }
        
        button#bom-btn {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8.47 8.47'%3E%3Crect transform='translate(0 -288.53)' ry='1.17' y='288.8' x='.27' height='7.94' width='7.94' fill='%23f9f9f9'/%3E%3Cg transform='translate(0 -288.53)' fill='none' stroke='%23000' stroke-width='.4'%3E%3Crect width='7.94' height='7.94' x='.27' y='288.8' ry='1.17' stroke-linejoin='round'/%3E%3Cpath d='M1.59 290.12h5.29M1.59 291.45h5.33M1.59 292.75h5.33M1.59 294.09h5.33M1.59 295.41h5.33'/%3E%3C/g%3E%3C/svg%3E");
        }
        
        button#bom-grouped-btn {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cg stroke='%23000' stroke-linejoin='round' class='layer'%3E%3Crect width='29' height='29' x='1.5' y='1.5' stroke-width='2' fill='%23fff' rx='5' ry='5'/%3E%3Cpath stroke-linecap='square' stroke-width='2' d='M6 10h4m4 0h5m4 0h3M6.1 22h3m3.9 0h5m4 0h4m-16-8h4m4 0h4'/%3E%3Cpath stroke-linecap='null' d='M5 17.5h22M5 26.6h22M5 5.5h22'/%3E%3C/g%3E%3C/svg%3E");
        }
        
        button#bom-ungrouped-btn {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cg stroke='%23000' stroke-linejoin='round' class='layer'%3E%3Crect width='29' height='29' x='1.5' y='1.5' stroke-width='2' fill='%23fff' rx='5' ry='5'/%3E%3Cpath stroke-linecap='square' stroke-width='2' d='M6 10h4m-4 8h3m-3 8h4'/%3E%3Cpath stroke-linecap='null' d='M5 13.5h22m-22 8h22M5 5.5h22'/%3E%3C/g%3E%3C/svg%3E");
        }
        
        button#bom-netlist-btn {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cg fill='none' stroke='%23000' class='layer'%3E%3Crect width='29' height='29' x='1.5' y='1.5' stroke-width='2' fill='%23fff' rx='5' ry='5'/%3E%3Cpath stroke-width='2' d='M6 26l6-6v-8m13.8-6.3l-6 6v8'/%3E%3Ccircle cx='11.8' cy='9.5' r='2.8' stroke-width='2'/%3E%3Ccircle cx='19.8' cy='22.8' r='2.8' stroke-width='2'/%3E%3C/g%3E%3C/svg%3E");
        }
        
        button#copy {
            background-image: url("data:image/svg+xml,%3Csvg height='48' viewBox='0 0 48 48' width='48' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h48v48h-48z' fill='none'/%3E%3Cpath d='M32 2h-24c-2.21 0-4 1.79-4 4v28h4v-28h24v-4zm6 8h-22c-2.21 0-4 1.79-4 4v28c0 2.21 1.79 4 4 4h22c2.21 0 4-1.79 4-4v-28c0-2.21-1.79-4-4-4zm0 32h-22v-28h22v28z'/%3E%3C/svg%3E");
            background-position: 6px 6px;
            background-repeat: no-repeat;
            background-size: 26px 26px;
            border-radius: 6px;
            height: 40px;
            width: 40px;
            margin: 10px 5px;
        }
        
        button#copy:active {
            box-shadow: inset 0px 0px 5px #6c6c6c;
        }
        
        textarea.clipboard-temp {
            position: fixed;
            top: 0;
            left: 0;
            width: 2em;
            height: 2em;
            padding: 0;
            border: None;
            outline: None;
            box-shadow: None;
            background: transparent;
        }
        
        .left-most-button {
            border-right: 0;
            border-top-left-radius: 6px;
            border-bottom-left-radius: 6px;
        }
        
        .middle-button {
            border-right: 0;
        }
        
        .right-most-button {
            border-top-right-radius: 6px;
            border-bottom-right-radius: 6px;
        }
        
        .button-container {
            font-size: 0;
            margin: 10px 10px 10px 0px;
        }
        
        .dark .button-container {
            filter: invert(1);
        }
        
        .button-container button {
            background-size: 32px 32px;
            background-position: 5px 5px;
            background-repeat: no-repeat;
        }
        
        @media print {
            .hideonprint {
                display: none;
            }
        }
        
        canvas {
            cursor: crosshair;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .fileinfo {
            width: 100%;
            max-width: 1000px;
            border: none;
            padding: 5px;
        }
        
        .fileinfo .title {
            font-size: 20pt;
            font-weight: bold;
        }
        
        .fileinfo td {
            overflow: hidden;
            white-space: nowrap;
            max-width: 1px;
            width: 50%;
            text-overflow: ellipsis;
        }
        
        .bom {
            border-collapse: collapse;
            font-family: Consolas, "DejaVu Sans Mono", Monaco, monospace;
            font-size: 10pt;
            table-layout: fixed;
            width: 100%;
            margin-top: 1px;
        }
        
        .bom th,
        .bom td {
            border: 1px solid black;
            padding: 5px;
            word-wrap: break-word;
            text-align: center;
            position: relative;
        }
        
        .dark .bom th,
        .dark .bom td {
            border: 1px solid #777;
        }
        
        .bom th {
            background-color: #CCCCCC;
            background-clip: padding-box;
        }
        
        .dark .bom th {
            background-color: #3b4749;
        }
        
        .bom tr.highlighted:nth-child(n) {
            background-color: #cfc;
        }
        
        .dark .bom tr.highlighted:nth-child(n) {
            background-color: #226022;
        }
        
        .bom tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .dark .bom tr:nth-child(even) {
            background-color: #313b40;
        }
        
        .bom tr.checked {
            color: #aaa;
        }
        
        .dark .bom tr.checked {
            color: #666;
        }
        
        .bom tr {
            transition: background-color 0.2s;
        }
        
        .bom .numCol {
            width: 25px;
        }
        
        .bom .Description {
            width: 10%;
        }
        
        .bom .Part {
            width: 10%;
        }
        
        .bom .Value {
            width: 15%;
        }
        
        .bom .Quantity {
            width: 65px;
        }
        
        .bom th .sortmark {
            position: absolute;
            right: 1px;
            top: 1px;
            margin-top: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent #221 transparent;
            transform-origin: 50% 85%;
            transition: opacity 0.2s, transform 0.4s;
        }
        
        .dark .bom th .sortmark {
            filter: invert(1);
        }
        
        .bom th .sortmark.none {
            opacity: 0;
        }
        
        .bom th .sortmark.desc {
            transform: rotate(180deg);
        }
        
        .bom th:hover .sortmark.none {
            opacity: 0.5;
        }
        
        .bom .bom-checkbox {
            width: 30px;
            position: relative;
            user-select: none;
            -moz-user-select: none;
        }
        
        .bom .bom-checkbox:before {
            content: "";
            position: absolute;
            border-width: 15px;
            border-style: solid;
            border-color: #51829f transparent transparent transparent;
            visibility: hidden;
            top: -15px;
        }
        
        .bom .bom-checkbox:after {
            content: "Double click to set/unset all";
            position: absolute;
            color: white;
            top: -35px;
            left: -26px;
            background: #51829f;
            padding: 5px 15px;
            border-radius: 8px;
            white-space: nowrap;
            visibility: hidden;
        }
        
        .bom .bom-checkbox:hover:before,
        .bom .bom-checkbox:hover:after {
            visibility: visible;
            transition: visibility 0.2s linear 1s;
        }
        
        .split {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
            overflow-y: auto;
            overflow-x: hidden;
            background-color: inherit;
        }
        
        .split.split-horizontal,
        .gutter.gutter-horizontal {
            height: 100%;
            float: left;
        }
        
        .gutter {
            background-color: #ddd;
            background-repeat: no-repeat;
            background-position: 50%;
            transition: background-color 0.3s;
        }
        
        .dark .gutter {
            background-color: #777;
        }
        
        .gutter.gutter-horizontal {
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==');
            cursor: ew-resize;
            width: 5px;
        }
        
        .gutter.gutter-vertical {
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFAQMAAABo7865AAAABlBMVEVHcEzMzMzyAv2sAAAAAXRSTlMAQObYZgAAABBJREFUeF5jOAMEEAIEEFwAn3kMwcB6I2AAAAAASUVORK5CYII=');
            cursor: ns-resize;
            height: 5px;
        }
        
        .searchbox {
            float: left;
            height: 40px;
            margin: 10px 5px;
            padding: 12px 32px;
            font-family: Consolas, "DejaVu Sans Mono", Monaco, monospace;
            font-size: 18px;
            box-sizing: border-box;
            border: 1px solid #888;
            border-radius: 6px;
            outline: none;
            background-color: #eee;
            transition: background-color 0.2s, border 0.2s;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABNklEQVQ4T8XSMUvDQBQH8P/LElFa/AIZHcTBQSz0I/gFstTBRR2KUC4ldDxw7h0Bl3RRUATxi4iiODgoiLNrbQYp5J6cpJJqomkX33Z37/14d/dIa33MzDuYI4johOI4XhyNRteO46zNYjDzAxE1yBZprVeZ+QbAUhXEGJMA2Ox2u4+fQIa0mPmsCgCgJYQ4t7lfgF0opQYAdv9ABkKI/UnOFCClXKjX61cA1osQY8x9kiRNKeV7IWA3oyhaSdP0FkAtjxhj3hzH2RBCPOf3pzqYHCilfAAX+URm9oMguPzeWSGQvUcMYC8rOBJCHBRdqxTo9/vbRHRqi8bj8XKv1xvODbiuW2u32/bvf0SlDv4XYOY7z/Mavu+nM1+BmQ+NMc0wDF/LprP0DbTWW0T00ul0nn4b7Q87+X4Qmfiq2wAAAABJRU5ErkJggg==');
            background-position: 10px 10px;
            background-repeat: no-repeat;
        }
        
        .dark .searchbox {
            background-color: #111;
            color: #eee;
        }
        
        .searchbox::placeholder {
            color: #ccc;
        }
        
        .dark .searchbox::placeholder {
            color: #666;
        }
        
        .filter {
            width: calc(60% - 64px);
        }
        
        .reflookup {
            width: calc(40% - 10px);
        }
        
        input[type=text]:focus {
            background-color: white;
            border: 1px solid #333;
        }
        
        .dark input[type=text]:focus {
            background-color: #333;
            border: 1px solid #ccc;
        }
        
        mark.highlight {
            background-color: #5050ff;
            color: #fff;
            padding: 2px;
            border-radius: 6px;
        }
        
        .dark mark.highlight {
            background-color: #76a6da;
            color: #111;
        }
        
        .menubtn {
            background-color: white;
            border: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='36' viewBox='0 0 20 20'%3E%3Cpath fill='none' d='M0 0h20v20H0V0z'/%3E%3Cpath d='M15.95 10.78c.03-.25.05-.51.05-.78s-.02-.53-.06-.78l1.69-1.32c.15-.12.19-.34.1-.51l-1.6-2.77c-.1-.18-.31-.24-.49-.18l-1.99.8c-.42-.32-.86-.58-1.35-.78L12 2.34c-.03-.2-.2-.34-.4-.34H8.4c-.2 0-.36.14-.39.34l-.3 2.12c-.49.2-.94.47-1.35.78l-1.99-.8c-.18-.07-.39 0-.49.18l-1.6 2.77c-.1.18-.06.39.1.51l1.69 1.32c-.04.25-.07.52-.07.78s.02.53.06.78L2.37 12.1c-.15.12-.19.34-.1.51l1.6 2.77c.1.18.31.24.49.18l1.99-.8c.42.32.86.58 1.35.78l.3 2.12c.04.2.2.34.4.34h3.2c.2 0 .37-.14.39-.34l.3-2.12c.49-.2.94-.47 1.35-.78l1.99.8c.18.07.39 0 .49-.18l1.6-2.77c.1-.18.06-.39-.1-.51l-1.67-1.32zM10 13c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3z'/%3E%3C/svg%3E%0A");
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .statsbtn {
            background-color: white;
            border: none;
            background-image: url("data:image/svg+xml,%3Csvg width='36' height='36' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M4 6h28v24H4V6zm0 8h28v8H4m9-16v24h10V5.8' fill='none' stroke='%23000' stroke-width='2'/%3E%3C/svg%3E");
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .iobtn {
            background-color: white;
            border: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='36'%3E%3Cpath fill='none' stroke='%23000' stroke-width='2' d='M3 33v-7l6.8-7h16.5l6.7 7v7H3zM3.2 26H33M21 9l5-5.9 5 6h-2.5V15h-5V9H21zm-4.9 0l-5 6-5-6h2.5V3h5v6h2.5z'/%3E%3Cpath fill='none' stroke='%23000' d='M6.1 29.5H10'/%3E%3C/svg%3E");
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .dark .statsbtn,
        .dark .savebtn,
        .dark .menubtn,
        .dark .iobtn {
            filter: invert(1);
        }
        
        .flexbox {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }
        
        .savebtn {
            background-color: #d6d6d6;
            width: auto;
            height: 30px;
            flex-grow: 1;
            margin: 5px;
            border-radius: 4px;
        }
        
        .savebtn:active {
            background-color: #0a0;
            color: white;
        }
        
        .dark .savebtn:active {
            /* This will be inverted */
            background-color: #b3b;
        }
        
        .stats {
            border-collapse: collapse;
            font-size: 12pt;
            table-layout: fixed;
            width: 100%;
            min-width: 450px;
        }
        
        .dark .stats td {
            border: 1px solid #bbb;
        }
        
        .stats td {
            border: 1px solid black;
            padding: 5px;
            word-wrap: break-word;
            text-align: center;
            position: relative;
        }
        
        #checkbox-stats div {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #checkbox-stats .bar {
            background-color: rgba(28, 251, 0, 0.6);
        }
        
        .menu {
            position: relative;
            display: inline-block;
            margin: 10px 10px 10px 0px;
        }
        
        .menu-content {
            display: none;
            position: absolute;
            background-color: white;
            right: 0;
            min-width: 300px;
            box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
            z-index: 100;
            padding: 8px;
        }
        
        .dark .menu-content {
            background-color: #111;
        }
        
        .menu:hover .menu-content {
            display: block;
        }
        
        .menu:hover .menubtn,
        .menu:hover .iobtn,
        .menu:hover .statsbtn {
            background-color: #eee;
        }
        
        .menu-label {
            display: inline-block;
            padding: 8px;
            border: 1px solid #ccc;
            border-top: 0;
            width: calc(100% - 18px);
        }
        
        .menu-label-top {
            border-top: 1px solid #ccc;
        }
        
        .menu-textbox {
            float: left;
            height: 24px;
            margin: 10px 5px;
            padding: 5px 5px;
            font-family: Consolas, "DejaVu Sans Mono", Monaco, monospace;
            font-size: 14px;
            box-sizing: border-box;
            border: 1px solid #888;
            border-radius: 4px;
            outline: none;
            background-color: #eee;
            transition: background-color 0.2s, border 0.2s;
            width: calc(100% - 10px);
        }
        
        .menu-textbox.invalid,
        .dark .menu-textbox.invalid {
            color: red;
        }
        
        .dark .menu-textbox {
            background-color: #222;
            color: #eee;
        }
        
        .radio-container {
            margin: 4px;
        }
        
        .topmostdiv {
            width: 100%;
            height: 100%;
            background-color: white;
            transition: background-color 0.3s;
        }
        
        #top {
            height: 78px;
            border-bottom: 2px solid black;
        }
        
        .dark #top {
            border-bottom: 2px solid #ccc;
        }
        
        #dbg {
            display: block;
        }
        
         ::-webkit-scrollbar {
            width: 8px;
        }
        
         ::-webkit-scrollbar-track {
            background: #aaa;
        }
        
         ::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 3px;
        }
        
         ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .slider {
            -webkit-appearance: none;
            width: 100%;
            margin: 3px 0;
            padding: 0;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 3px;
        }
        
        .slider:hover {
            opacity: 1;
        }
        
        .slider:focus {
            outline: none;
        }
        
        .slider::-webkit-slider-runnable-track {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #d3d3d3;
            border-radius: 3px;
            border: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #0a0;
            cursor: pointer;
            margin-top: -4px;
        }
        
        .dark .slider::-webkit-slider-thumb {
            background: #3d3;
        }
        
        .slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #0a0;
            cursor: pointer;
        }
        
        .slider::-moz-range-track {
            height: 8px;
            background: #d3d3d3;
            border-radius: 3px;
        }
        
        .dark .slider::-moz-range-thumb {
            background: #3d3;
        }
        
        .slider::-ms-track {
            width: 100%;
            height: 8px;
            border-width: 3px 0;
            background: transparent;
            border-color: transparent;
            color: transparent;
            transition: opacity .2s;
        }
        
        .slider::-ms-fill-lower {
            background: #d3d3d3;
            border: none;
            border-radius: 3px;
        }
        
        .slider::-ms-fill-upper {
            background: #d3d3d3;
            border: none;
            border-radius: 3px;
        }
        
        .slider::-ms-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #0a0;
            cursor: pointer;
            margin: 0;
        }
        
        .shameless-plug {
            font-size: 0.8em;
            text-align: center;
            display: block;
        }
        
        a {
            color: #0278a4;
        }
        
        .dark a {
            color: #00b9fd;
        }
        
        #frontcanvas,
        #backcanvas {
            touch-action: none;
        }
    </style>
    <script type="text/javascript">
        ///////////////////////////////////////////////
        /*
          Split.js - v1.3.5
          MIT License
          https://github.com/nathancahill/Split.js
        */
        ! function(e, t) {
            "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.Split = t()
        }(this, function() {
            "use strict";
            var e = window,
                t = e.document,
                n = "addEventListener",
                i = "removeEventListener",
                r = "getBoundingClientRect",
                s = function() {
                    return !1
                },
                o = e.attachEvent && !e[n],
                a = ["", "-webkit-", "-moz-", "-o-"].filter(function(e) {
                    var n = t.createElement("div");
                    return n.style.cssText = "width:" + e + "calc(9px)", !!n.style.length
                }).shift() + "calc",
                l = function(e) {
                    return "string" == typeof e || e instanceof String ? t.querySelector(e) : e
                };
            return function(u, c) {
                function z(e, t, n) {
                    var i = A(y, t, n);
                    Object.keys(i).forEach(function(t) {
                        return e.style[t] = i[t]
                    })
                }

                function h(e, t) {
                    var n = B(y, t);
                    Object.keys(n).forEach(function(t) {
                        return e.style[t] = n[t]
                    })
                }

                function f(e) {
                    var t = E[this.a],
                        n = E[this.b],
                        i = t.size + n.size;
                    t.size = e / this.size * i, n.size = i - e / this.size * i, z(t.element, t.size, this.aGutterSize), z(n.element, n.size, this.bGutterSize)
                }

                function m(e) {
                    var t;
                    this.dragging && ((t = "touches" in e ? e.touches[0][b] - this.start : e[b] - this.start) <= E[this.a].minSize + M + this.aGutterSize ? t = E[this.a].minSize + this.aGutterSize : t >= this.size - (E[this.b].minSize + M + this.bGutterSize) && (t = this.size - (E[this.b].minSize + this.bGutterSize)), f.call(this, t), c.onDrag && c.onDrag())
                }

                function g() {
                    var e = E[this.a].element,
                        t = E[this.b].element;
                    this.size = e[r]()[y] + t[r]()[y] + this.aGutterSize + this.bGutterSize, this.start = e[r]()[G]
                }

                function d() {
                    var t = this,
                        n = E[t.a].element,
                        r = E[t.b].element;
                    t.dragging && c.onDragEnd && c.onDragEnd(), t.dragging = !1, e[i]("mouseup", t.stop), e[i]("touchend", t.stop), e[i]("touchcancel", t.stop), t.parent[i]("mousemove", t.move), t.parent[i]("touchmove", t.move), delete t.stop, delete t.move, n[i]("selectstart", s), n[i]("dragstart", s), r[i]("selectstart", s), r[i]("dragstart", s), n.style.userSelect = "", n.style.webkitUserSelect = "", n.style.MozUserSelect = "", n.style.pointerEvents = "", r.style.userSelect = "", r.style.webkitUserSelect = "", r.style.MozUserSelect = "", r.style.pointerEvents = "", t.gutter.style.cursor = "", t.parent.style.cursor = ""
                }

                function S(t) {
                    var i = this,
                        r = E[i.a].element,
                        o = E[i.b].element;
                    !i.dragging && c.onDragStart && c.onDragStart(), t.preventDefault(), i.dragging = !0, i.move = m.bind(i), i.stop = d.bind(i), e[n]("mouseup", i.stop), e[n]("touchend", i.stop), e[n]("touchcancel", i.stop), i.parent[n]("mousemove", i.move), i.parent[n]("touchmove", i.move), r[n]("selectstart", s), r[n]("dragstart", s), o[n]("selectstart", s), o[n]("dragstart", s), r.style.userSelect = "none", r.style.webkitUserSelect = "none", r.style.MozUserSelect = "none", r.style.pointerEvents = "none", o.style.userSelect = "none", o.style.webkitUserSelect = "none", o.style.MozUserSelect = "none", o.style.pointerEvents = "none", i.gutter.style.cursor = j, i.parent.style.cursor = j, g.call(i)
                }

                function v(e) {
                    e.forEach(function(t, n) {
                        if (n > 0) {
                            var i = F[n - 1],
                                r = E[i.a],
                                s = E[i.b];
                            r.size = e[n - 1], s.size = t, z(r.element, r.size, i.aGutterSize), z(s.element, s.size, i.bGutterSize)
                        }
                    })
                }

                function p() {
                    F.forEach(function(e) {
                        e.parent.removeChild(e.gutter), E[e.a].element.style[y] = "", E[e.b].element.style[y] = ""
                    })
                }
                void 0 === c && (c = {});
                var y, b, G, E, w = l(u[0]).parentNode,
                    D = e.getComputedStyle(w).flexDirection,
                    U = c.sizes || u.map(function() {
                        return 100 / u.length
                    }),
                    k = void 0 !== c.minSize ? c.minSize : 100,
                    x = Array.isArray(k) ? k : u.map(function() {
                        return k
                    }),
                    L = void 0 !== c.gutterSize ? c.gutterSize : 10,
                    M = void 0 !== c.snapOffset ? c.snapOffset : 30,
                    O = c.direction || "horizontal",
                    j = c.cursor || ("horizontal" === O ? "ew-resize" : "ns-resize"),
                    C = c.gutter || function(e, n) {
                        var i = t.createElement("div");
                        return i.className = "gutter gutter-" + n, i
                    },
                    A = c.elementStyle || function(e, t, n) {
                        var i = {};
                        return "string" == typeof t || t instanceof String ? i[e] = t : i[e] = o ? t + "%" : a + "(" + t + "% - " + n + "px)", i
                    },
                    B = c.gutterStyle || function(e, t) {
                        return n = {}, n[e] = t + "px", n;
                        var n
                    };
                "horizontal" === O ? (y = "width", "clientWidth", b = "clientX", G = "left", "paddingLeft") : "vertical" === O && (y = "height", "clientHeight", b = "clientY", G = "top", "paddingTop");
                var F = [];
                return E = u.map(function(e, t) {
                    var i, s = {
                        element: l(e),
                        size: U[t],
                        minSize: x[t]
                    };
                    if (t > 0 && (i = {
                            a: t - 1,
                            b: t,
                            dragging: !1,
                            isFirst: 1 === t,
                            isLast: t === u.length - 1,
                            direction: O,
                            parent: w
                        }, i.aGutterSize = L, i.bGutterSize = L, i.isFirst && (i.aGutterSize = L / 2), i.isLast && (i.bGutterSize = L / 2), "row-reverse" === D || "column-reverse" === D)) {
                        var a = i.a;
                        i.a = i.b, i.b = a
                    }
                    if (!o && t > 0) {
                        var c = C(t, O);
                        h(c, L), c[n]("mousedown", S.bind(i)), c[n]("touchstart", S.bind(i)), w.insertBefore(c, s.element), i.gutter = c
                    }
                    0 === t || t === u.length - 1 ? z(s.element, s.size, L / 2) : z(s.element, s.size, L);
                    var f = s.element[r]()[y];
                    return f < s.minSize && (s.minSize = f), t > 0 && F.push(i), s
                }), o ? {
                    setSizes: v,
                    destroy: p
                } : {
                    setSizes: v,
                    getSizes: function() {
                        return E.map(function(e) {
                            return e.size
                        })
                    },
                    collapse: function(e) {
                        if (e === F.length) {
                            var t = F[e - 1];
                            g.call(t), o || f.call(t, t.size - t.bGutterSize)
                        } else {
                            var n = F[e];
                            g.call(n), o || f.call(n, n.aGutterSize)
                        }
                    },
                    destroy: p
                }
            }
        });

        ///////////////////////////////////////////////

        ///////////////////////////////////////////////
        // Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
        // This work is free. You can redistribute it and/or modify it
        // under the terms of the WTFPL, Version 2
        // For more information see LICENSE.txt or http://www.wtfpl.net/
        //
        // For more information, the home page:
        // http://pieroxy.net/blog/pages/lz-string/testing.html
        //
        // LZ-based compression algorithm, version 1.4.4
        var LZString = function() {
            var o = String.fromCharCode,
                i = {};
            var n = {
                decompressFromBase64: function(o) {
                    return null == o ? "" : "" == o ? null : n._decompress(o.length, 32, function(n) {
                        return function(o, n) {
                            if (!i[o]) {
                                i[o] = {};
                                for (var t = 0; t < o.length; t++) i[o][o.charAt(t)] = t
                            }
                            return i[o][n]
                        }("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", o.charAt(n))
                    })
                },
                _decompress: function(i, n, t) {
                    var r, e, a, s, p, u, l, f = [],
                        c = 4,
                        d = 4,
                        h = 3,
                        v = "",
                        g = [],
                        m = {
                            val: t(0),
                            position: n,
                            index: 1
                        };
                    for (r = 0; r < 3; r += 1) f[r] = r;
                    for (a = 0, p = Math.pow(2, 2), u = 1; u != p;) s = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = n, m.val = t(m.index++)), a |= (s > 0 ? 1 : 0) * u, u <<= 1;
                    switch (a) {
                        case 0:
                            for (a = 0, p = Math.pow(2, 8), u = 1; u != p;) s = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = n, m.val = t(m.index++)), a |= (s > 0 ? 1 : 0) * u, u <<= 1;
                            l = o(a);
                            break;
                        case 1:
                            for (a = 0, p = Math.pow(2, 16), u = 1; u != p;) s = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = n, m.val = t(m.index++)), a |= (s > 0 ? 1 : 0) * u, u <<= 1;
                            l = o(a);
                            break;
                        case 2:
                            return ""
                    }
                    for (f[3] = l, e = l, g.push(l);;) {
                        if (m.index > i) return "";
                        for (a = 0, p = Math.pow(2, h), u = 1; u != p;) s = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = n, m.val = t(m.index++)), a |= (s > 0 ? 1 : 0) * u, u <<= 1;
                        switch (l = a) {
                            case 0:
                                for (a = 0, p = Math.pow(2, 8), u = 1; u != p;) s = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = n, m.val = t(m.index++)), a |= (s > 0 ? 1 : 0) * u, u <<= 1;
                                f[d++] = o(a), l = d - 1, c--;
                                break;
                            case 1:
                                for (a = 0, p = Math.pow(2, 16), u = 1; u != p;) s = m.val & m.position, m.position >>= 1, 0 == m.position && (m.position = n, m.val = t(m.index++)), a |= (s > 0 ? 1 : 0) * u, u <<= 1;
                                f[d++] = o(a), l = d - 1, c--;
                                break;
                            case 2:
                                return g.join("")
                        }
                        if (0 == c && (c = Math.pow(2, h), h++), f[l]) v = f[l];
                        else {
                            if (l !== d) return null;
                            v = e + e.charAt(0)
                        }
                        g.push(v), f[d++] = e + v.charAt(0), e = v, 0 == --c && (c = Math.pow(2, h), h++)
                    }
                }
            };
            return n
        }();
        "function" == typeof define && define.amd ? define(function() {
            return LZString
        }) : "undefined" != typeof module && null != module ? module.exports = LZString : "undefined" != typeof angular && null != angular && angular.module("LZString", []).factory("LZString", function() {
            return LZString
        });
        ///////////////////////////////////////////////

        ///////////////////////////////////////////////
        /*!
         * PEP v0.4.3 | https://github.com/jquery/PEP
         * Copyright jQuery Foundation and other contributors | http://jquery.org/license
         */
        ! function(a, b) {
            "object" == typeof exports && "undefined" != typeof module ? module.exports = b() : "function" == typeof define && define.amd ? define(b) : a.PointerEventsPolyfill = b()
        }(this, function() {
            "use strict";

            function a(a, b) {
                b = b || Object.create(null);
                var c = document.createEvent("Event");
                c.initEvent(a, b.bubbles || !1, b.cancelable || !1);
                for (var d, e = 2; e < m.length; e++) d = m[e], c[d] = b[d] || n[e];
                c.buttons = b.buttons || 0;
                var f = 0;
                return f = b.pressure && c.buttons ? b.pressure : c.buttons ? .5 : 0, c.x = c.clientX, c.y = c.clientY, c.pointerId = b.pointerId || 0, c.width = b.width || 0, c.height = b.height || 0, c.pressure = f, c.tiltX = b.tiltX || 0, c.tiltY = b.tiltY || 0, c.twist = b.twist || 0, c.tangentialPressure = b.tangentialPressure || 0, c.pointerType = b.pointerType || "", c.hwTimestamp = b.hwTimestamp || 0, c.isPrimary = b.isPrimary || !1, c
            }

            function b() {
                this.array = [], this.size = 0
            }

            function c(a, b, c, d) {
                this.addCallback = a.bind(d), this.removeCallback = b.bind(d), this.changedCallback = c.bind(d), A && (this.observer = new A(this.mutationWatcher.bind(this)))
            }

            function d(a) {
                return "body /shadow-deep/ " + e(a)
            }

            function e(a) {
                return '[touch-action="' + a + '"]'
            }

            function f(a) {
                return "{ -ms-touch-action: " + a + "; touch-action: " + a + "; }"
            }

            function g() {
                if (F) {
                    D.forEach(function(a) {
                        String(a) === a ? (E += e(a) + f(a) + "\n", G && (E += d(a) + f(a) + "\n")) : (E += a.selectors.map(e) + f(a.rule) + "\n", G && (E += a.selectors.map(d) + f(a.rule) + "\n"))
                    });
                    var a = document.createElement("style");
                    a.textContent = E, document.head.appendChild(a)
                }
            }

            function h() {
                if (!window.PointerEvent) {
                    if (window.PointerEvent = a, window.navigator.msPointerEnabled) {
                        var b = window.navigator.msMaxTouchPoints;
                        Object.defineProperty(window.navigator, "maxTouchPoints", {
                            value: b,
                            enumerable: !0
                        }), u.registerSource("ms", _)
                    } else Object.defineProperty(window.navigator, "maxTouchPoints", {
                        value: 0,
                        enumerable: !0
                    }), u.registerSource("mouse", N), void 0 !== window.ontouchstart && u.registerSource("touch", V);
                    u.register(document)
                }
            }

            function i(a) {
                if (!u.pointermap.has(a)) {
                    var b = new Error("InvalidPointerId");
                    throw b.name = "InvalidPointerId", b
                }
            }

            function j(a) {
                for (var b = a.parentNode; b && b !== a.ownerDocument;) b = b.parentNode;
                if (!b) {
                    var c = new Error("InvalidStateError");
                    throw c.name = "InvalidStateError", c
                }
            }

            function k(a) {
                var b = u.pointermap.get(a);
                return 0 !== b.buttons
            }

            function l() {
                window.Element && !Element.prototype.setPointerCapture && Object.defineProperties(Element.prototype, {
                    setPointerCapture: {
                        value: W
                    },
                    releasePointerCapture: {
                        value: X
                    },
                    hasPointerCapture: {
                        value: Y
                    }
                })
            }
            var m = ["bubbles", "cancelable", "view", "detail", "screenX", "screenY", "clientX", "clientY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "relatedTarget", "pageX", "pageY"],
                n = [!1, !1, null, null, 0, 0, 0, 0, !1, !1, !1, !1, 0, null, 0, 0],
                o = window.Map && window.Map.prototype.forEach,
                p = o ? Map : b;
            b.prototype = {
                set: function(a, b) {
                    return void 0 === b ? this["delete"](a) : (this.has(a) || this.size++, void(this.array[a] = b))
                },
                has: function(a) {
                    return void 0 !== this.array[a]
                },
                "delete": function(a) {
                    this.has(a) && (delete this.array[a], this.size--)
                },
                get: function(a) {
                    return this.array[a]
                },
                clear: function() {
                    this.array.length = 0, this.size = 0
                },
                forEach: function(a, b) {
                    return this.array.forEach(function(c, d) {
                        a.call(b, c, d, this)
                    }, this)
                }
            };
            var q = ["bubbles", "cancelable", "view", "detail", "screenX", "screenY", "clientX", "clientY", "ctrlKey", "altKey", "shiftKey", "metaKey", "button", "relatedTarget", "buttons", "pointerId", "width", "height", "pressure", "tiltX", "tiltY", "pointerType", "hwTimestamp", "isPrimary", "type", "target", "currentTarget", "which", "pageX", "pageY", "timeStamp"],
                r = [!1, !1, null, null, 0, 0, 0, 0, !1, !1, !1, !1, 0, null, 0, 0, 0, 0, 0, 0, 0, "", 0, !1, "", null, null, 0, 0, 0, 0],
                s = {
                    pointerover: 1,
                    pointerout: 1,
                    pointerenter: 1,
                    pointerleave: 1
                },
                t = "undefined" != typeof SVGElementInstance,
                u = {
                    pointermap: new p,
                    eventMap: Object.create(null),
                    captureInfo: Object.create(null),
                    eventSources: Object.create(null),
                    eventSourceList: [],
                    registerSource: function(a, b) {
                        var c = b,
                            d = c.events;
                        d && (d.forEach(function(a) {
                            c[a] && (this.eventMap[a] = c[a].bind(c))
                        }, this), this.eventSources[a] = c, this.eventSourceList.push(c))
                    },
                    register: function(a) {
                        for (var b, c = this.eventSourceList.length, d = 0; d < c && (b = this.eventSourceList[d]); d++)
                            b.register.call(b, a)
                    },
                    unregister: function(a) {
                        for (var b, c = this.eventSourceList.length, d = 0; d < c && (b = this.eventSourceList[d]); d++)
                            b.unregister.call(b, a)
                    },
                    contains: function(a, b) {
                        try {
                            return a.contains(b)
                        } catch (c) {
                            return !1
                        }
                    },
                    down: function(a) {
                        a.bubbles = !0, this.fireEvent("pointerdown", a)
                    },
                    move: function(a) {
                        a.bubbles = !0, this.fireEvent("pointermove", a)
                    },
                    up: function(a) {
                        a.bubbles = !0, this.fireEvent("pointerup", a)
                    },
                    enter: function(a) {
                        a.bubbles = !1, this.fireEvent("pointerenter", a)
                    },
                    leave: function(a) {
                        a.bubbles = !1, this.fireEvent("pointerleave", a)
                    },
                    over: function(a) {
                        a.bubbles = !0, this.fireEvent("pointerover", a)
                    },
                    out: function(a) {
                        a.bubbles = !0, this.fireEvent("pointerout", a)
                    },
                    cancel: function(a) {
                        a.bubbles = !0, this.fireEvent("pointercancel", a)
                    },
                    leaveOut: function(a) {
                        this.out(a), this.propagate(a, this.leave, !1)
                    },
                    enterOver: function(a) {
                        this.over(a), this.propagate(a, this.enter, !0)
                    },
                    eventHandler: function(a) {
                        if (!a._handledByPE) {
                            var b = a.type,
                                c = this.eventMap && this.eventMap[b];
                            c && c(a), a._handledByPE = !0
                        }
                    },
                    listen: function(a, b) {
                        b.forEach(function(b) {
                            this.addEvent(a, b)
                        }, this)
                    },
                    unlisten: function(a, b) {
                        b.forEach(function(b) {
                            this.removeEvent(a, b)
                        }, this)
                    },
                    addEvent: function(a, b) {
                        a.addEventListener(b, this.boundHandler)
                    },
                    removeEvent: function(a, b) {
                        a.removeEventListener(b, this.boundHandler)
                    },
                    makeEvent: function(b, c) {
                        this.captureInfo[c.pointerId] && (c.relatedTarget = null);
                        var d = new a(b, c);
                        return c.preventDefault && (d.preventDefault = c.preventDefault), d._target = d._target || c.target, d
                    },
                    fireEvent: function(a, b) {
                        var c = this.makeEvent(a, b);
                        return this.dispatchEvent(c)
                    },
                    cloneEvent: function(a) {
                        for (var b, c = Object.create(null), d = 0; d < q.length; d++) b = q[d], c[b] = a[b] || r[d], !t || "target" !== b && "relatedTarget" !== b || c[b] instanceof SVGElementInstance && (c[b] = c[b].correspondingUseElement);
                        return a.preventDefault && (c.preventDefault = function() {
                            a.preventDefault()
                        }), c
                    },
                    getTarget: function(a) {
                        var b = this.captureInfo[a.pointerId];
                        return b ? a._target !== b && a.type in s ? void 0 : b : a._target
                    },
                    propagate: function(a, b, c) {
                        for (var d = a.target, e = []; d !== document && !d.contains(a.relatedTarget);)
                            if (e.push(d), d = d.parentNode, !d) return;
                        c && e.reverse(), e.forEach(function(c) {
                            a.target = c, b.call(this, a)
                        }, this)
                    },
                    setCapture: function(b, c, d) {
                        this.captureInfo[b] && this.releaseCapture(b, d), this.captureInfo[b] = c, this.implicitRelease = this.releaseCapture.bind(this, b, d), document.addEventListener("pointerup", this.implicitRelease), document.addEventListener("pointercancel", this.implicitRelease);
                        var e = new a("gotpointercapture");
                        e.pointerId = b, e._target = c, d || this.asyncDispatchEvent(e)
                    },
                    releaseCapture: function(b, c) {
                        var d = this.captureInfo[b];
                        if (d) {
                            this.captureInfo[b] = void 0, document.removeEventListener("pointerup", this.implicitRelease), document.removeEventListener("pointercancel", this.implicitRelease);
                            var e = new a("lostpointercapture");
                            e.pointerId = b, e._target = d, c || this.asyncDispatchEvent(e)
                        }
                    },
                    dispatchEvent: /*scope.external.dispatchEvent || */ function(a) {
                        var b = this.getTarget(a);
                        if (b) return b.dispatchEvent(a)
                    },
                    asyncDispatchEvent: function(a) {
                        requestAnimationFrame(this.dispatchEvent.bind(this, a))
                    }
                };
            u.boundHandler = u.eventHandler.bind(u);
            var v = {
                    shadow: function(a) {
                        if (a) return a.shadowRoot || a.webkitShadowRoot
                    },
                    canTarget: function(a) {
                        return a && Boolean(a.elementFromPoint)
                    },
                    targetingShadow: function(a) {
                        var b = this.shadow(a);
                        if (this.canTarget(b)) return b
                    },
                    olderShadow: function(a) {
                        var b = a.olderShadowRoot;
                        if (!b) {
                            var c = a.querySelector("shadow");
                            c && (b = c.olderShadowRoot)
                        }
                        return b
                    },
                    allShadows: function(a) {
                        for (var b = [], c = this.shadow(a); c;) b.push(c), c = this.olderShadow(c);
                        return b
                    },
                    searchRoot: function(a, b, c) {
                        if (a) {
                            var d, e, f = a.elementFromPoint(b, c);
                            for (e = this.targetingShadow(f); e;) {
                                if (d = e.elementFromPoint(b, c)) {
                                    var g = this.targetingShadow(d);
                                    return this.searchRoot(g, b, c) || d
                                }
                                e = this.olderShadow(e)
                            }
                            return f
                        }
                    },
                    owner: function(a) {
                        for (var b = a; b.parentNode;) b = b.parentNode;
                        return b.nodeType !== Node.DOCUMENT_NODE && b.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && (b = document), b
                    },
                    findTarget: function(a) {
                        var b = a.clientX,
                            c = a.clientY,
                            d = this.owner(a.target);
                        return d.elementFromPoint(b, c) || (d = document), this.searchRoot(d, b, c)
                    }
                },
                w = Array.prototype.forEach.call.bind(Array.prototype.forEach),
                x = Array.prototype.map.call.bind(Array.prototype.map),
                y = Array.prototype.slice.call.bind(Array.prototype.slice),
                z = Array.prototype.filter.call.bind(Array.prototype.filter),
                A = window.MutationObserver || window.WebKitMutationObserver,
                B = "[touch-action]",
                C = {
                    subtree: !0,
                    childList: !0,
                    attributes: !0,
                    attributeOldValue: !0,
                    attributeFilter: ["touch-action"]
                };
            c.prototype = {
                watchSubtree: function(a) {
                    //
                    this.observer && v.canTarget(a) && this.observer.observe(a, C)
                },
                enableOnSubtree: function(a) {
                    this.watchSubtree(a), a === document && "complete" !== document.readyState ? this.installOnLoad() : this.installNewSubtree(a)
                },
                installNewSubtree: function(a) {
                    w(this.findElements(a), this.addElement, this)
                },
                findElements: function(a) {
                    return a.querySelectorAll ? a.querySelectorAll(B) : []
                },
                removeElement: function(a) {
                    this.removeCallback(a)
                },
                addElement: function(a) {
                    this.addCallback(a)
                },
                elementChanged: function(a, b) {
                    this.changedCallback(a, b)
                },
                concatLists: function(a, b) {
                    return a.concat(y(b))
                },
                installOnLoad: function() {
                    document.addEventListener("readystatechange", function() {
                        "complete" === document.readyState && this.installNewSubtree(document)
                    }.bind(this))
                },
                isElement: function(a) {
                    return a.nodeType === Node.ELEMENT_NODE
                },
                flattenMutationTree: function(a) {
                    var b = x(a, this.findElements, this);
                    return b.push(z(a, this.isElement)), b.reduce(this.concatLists, [])
                },
                mutationWatcher: function(a) {
                    a.forEach(this.mutationHandler, this)
                },
                mutationHandler: function(a) {
                    if ("childList" === a.type) {
                        var b = this.flattenMutationTree(a.addedNodes);
                        b.forEach(this.addElement, this);
                        var c = this.flattenMutationTree(a.removedNodes);
                        c.forEach(this.removeElement, this)
                    } else "attributes" === a.type && this.elementChanged(a.target, a.oldValue)
                }
            };
            var D = ["none", "auto", "pan-x", "pan-y", {
                    rule: "pan-x pan-y",
                    selectors: ["pan-x pan-y", "pan-y pan-x"]
                }],
                E = "",
                F = window.PointerEvent || window.MSPointerEvent,
                G = !window.ShadowDOMPolyfill && document.head.createShadowRoot,
                H = u.pointermap,
                I = 25,
                J = [1, 4, 2, 8, 16],
                K = !1;
            try {
                K = 1 === new MouseEvent("test", {
                    buttons: 1
                }).buttons
            } catch (L) {}
            var M, N = {
                    POINTER_ID: 1,
                    POINTER_TYPE: "mouse",
                    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
                    register: function(a) {
                        u.listen(a, this.events)
                    },
                    unregister: function(a) {
                        u.unlisten(a, this.events)
                    },
                    lastTouches: [],
                    isEventSimulatedFromTouch: function(a) {
                        for (var b, c = this.lastTouches, d = a.clientX, e = a.clientY, f = 0, g = c.length; f < g && (b = c[f]); f++) {
                            var h = Math.abs(d - b.x),
                                i = Math.abs(e - b.y);
                            if (h <= I && i <= I) return !0
                        }
                    },
                    prepareEvent: function(a) {
                        var b = u.cloneEvent(a),
                            c = b.preventDefault;
                        return b.preventDefault = function() {
                            a.preventDefault(), c()
                        }, b.pointerId = this.POINTER_ID, b.isPrimary = !0, b.pointerType = this.POINTER_TYPE, b
                    },
                    prepareButtonsForMove: function(a, b) {
                        var c = H.get(this.POINTER_ID);
                        0 !== b.which && c ? a.buttons = c.buttons : a.buttons = 0, b.buttons = a.buttons
                    },
                    mousedown: function(a) {
                        if (!this.isEventSimulatedFromTouch(a)) {
                            var b = H.get(this.POINTER_ID),
                                c = this.prepareEvent(a);
                            K || (c.buttons = J[c.button], b && (c.buttons |= b.buttons), a.buttons = c.buttons), H.set(this.POINTER_ID, a), b && 0 !== b.buttons ? u.move(c) : u.down(c)
                        }
                    },
                    mousemove: function(a) {
                        if (!this.isEventSimulatedFromTouch(a)) {
                            var b = this.prepareEvent(a);
                            K || this.prepareButtonsForMove(b, a), b.button = -1, H.set(this.POINTER_ID, a), u.move(b)
                        }
                    },
                    mouseup: function(a) {
                        if (!this.isEventSimulatedFromTouch(a)) {
                            var b = H.get(this.POINTER_ID),
                                c = this.prepareEvent(a);
                            if (!K) {
                                var d = J[c.button];
                                c.buttons = b ? b.buttons & ~d : 0, a.buttons = c.buttons
                            }
                            H.set(this.POINTER_ID, a),
                                c.buttons &= ~J[c.button], 0 === c.buttons ? u.up(c) : u.move(c)
                        }
                    },
                    mouseover: function(a) {
                        if (!this.isEventSimulatedFromTouch(a)) {
                            var b = this.prepareEvent(a);
                            K || this.prepareButtonsForMove(b, a), b.button = -1, H.set(this.POINTER_ID, a), u.enterOver(b)
                        }
                    },
                    mouseout: function(a) {
                        if (!this.isEventSimulatedFromTouch(a)) {
                            var b = this.prepareEvent(a);
                            K || this.prepareButtonsForMove(b, a), b.button = -1, u.leaveOut(b)
                        }
                    },
                    cancel: function(a) {
                        var b = this.prepareEvent(a);
                        u.cancel(b), this.deactivateMouse()
                    },
                    deactivateMouse: function() {
                        H["delete"](this.POINTER_ID)
                    }
                },
                O = u.captureInfo,
                P = v.findTarget.bind(v),
                Q = v.allShadows.bind(v),
                R = u.pointermap,
                S = 2500,
                T = 200,
                U = "touch-action",
                V = {
                    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
                    register: function(a) {
                        M.enableOnSubtree(a)
                    },
                    unregister: function() {},
                    elementAdded: function(a) {
                        var b = a.getAttribute(U),
                            c = this.touchActionToScrollType(b);
                        c && (a._scrollType = c, u.listen(a, this.events),
                            Q(a).forEach(function(a) {
                                a._scrollType = c, u.listen(a, this.events)
                            }, this))
                    },
                    elementRemoved: function(a) {
                        a._scrollType = void 0, u.unlisten(a, this.events),
                            Q(a).forEach(function(a) {
                                a._scrollType = void 0, u.unlisten(a, this.events)
                            }, this)
                    },
                    elementChanged: function(a, b) {
                        var c = a.getAttribute(U),
                            d = this.touchActionToScrollType(c),
                            e = this.touchActionToScrollType(b);
                        d && e ? (a._scrollType = d, Q(a).forEach(function(a) {
                            a._scrollType = d
                        }, this)) : e ? this.elementRemoved(a) : d && this.elementAdded(a)
                    },
                    scrollTypes: {
                        EMITTER: "none",
                        XSCROLLER: "pan-x",
                        YSCROLLER: "pan-y",
                        SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
                    },
                    touchActionToScrollType: function(a) {
                        var b = a,
                            c = this.scrollTypes;
                        return "none" === b ? "none" : b === c.XSCROLLER ? "X" : b === c.YSCROLLER ? "Y" : c.SCROLLER.exec(b) ? "XY" : void 0
                    },
                    POINTER_TYPE: "touch",
                    firstTouch: null,
                    isPrimaryTouch: function(a) {
                        return this.firstTouch === a.identifier
                    },
                    setPrimaryTouch: function(a) {
                        (0 === R.size || 1 === R.size && R.has(1)) && (this.firstTouch = a.identifier, this.firstXY = {
                            X: a.clientX,
                            Y: a.clientY
                        }, this.scrolling = !1, this.cancelResetClickCount())
                    },
                    removePrimaryPointer: function(a) {
                        a.isPrimary && (this.firstTouch = null, this.firstXY = null, this.resetClickCount())
                    },
                    clickCount: 0,
                    resetId: null,
                    resetClickCount: function() {
                        var a = function() {
                            this.clickCount = 0, this.resetId = null
                        }.bind(this);
                        this.resetId = setTimeout(a, T)
                    },
                    cancelResetClickCount: function() {
                        this.resetId && clearTimeout(this.resetId)
                    },
                    typeToButtons: function(a) {
                        var b = 0;
                        return "touchstart" !== a && "touchmove" !== a || (b = 1), b
                    },
                    touchToPointer: function(a) {
                        var b = this.currentTouchEvent,
                            c = u.cloneEvent(a),
                            d = c.pointerId = a.identifier + 2;
                        c.target = O[d] || P(c), c.bubbles = !0, c.cancelable = !0, c.detail = this.clickCount, c.button = 0, c.buttons = this.typeToButtons(b.type), c.width = 2 * (a.radiusX || a.webkitRadiusX || 0), c.height = 2 * (a.radiusY || a.webkitRadiusY || 0), c.pressure = a.force || a.webkitForce || .5, c.isPrimary = this.isPrimaryTouch(a), c.pointerType = this.POINTER_TYPE,
                            c.altKey = b.altKey, c.ctrlKey = b.ctrlKey, c.metaKey = b.metaKey, c.shiftKey = b.shiftKey;
                        var e = this;
                        return c.preventDefault = function() {
                            e.scrolling = !1, e.firstXY = null, b.preventDefault()
                        }, c
                    },
                    processTouches: function(a, b) {
                        var c = a.changedTouches;
                        this.currentTouchEvent = a;
                        for (var d, e = 0; e < c.length; e++) d = c[e], b.call(this, this.touchToPointer(d))
                    },
                    shouldScroll: function(a) {
                        if (this.firstXY) {
                            var b, c = a.currentTarget._scrollType;
                            if ("none" === c)
                                b = !1;
                            else if ("XY" === c)
                                b = !0;
                            else {
                                var d = a.changedTouches[0],
                                    e = c,
                                    f = "Y" === c ? "X" : "Y",
                                    g = Math.abs(d["client" + e] - this.firstXY[e]),
                                    h = Math.abs(d["client" + f] - this.firstXY[f]);
                                b = g >= h
                            }
                            return this.firstXY = null, b
                        }
                    },
                    findTouch: function(a, b) {
                        for (var c, d = 0, e = a.length; d < e && (c = a[d]); d++)
                            if (c.identifier === b) return !0
                    },
                    vacuumTouches: function(a) {
                        var b = a.touches;
                        if (R.size >= b.length) {
                            var c = [];
                            R.forEach(function(a, d) {
                                if (1 !== d && !this.findTouch(b, d - 2)) {
                                    var e = a.out;
                                    c.push(e)
                                }
                            }, this), c.forEach(this.cancelOut, this)
                        }
                    },
                    touchstart: function(a) {
                        this.vacuumTouches(a), this.setPrimaryTouch(a.changedTouches[0]), this.dedupSynthMouse(a), this.scrolling || (this.clickCount++, this.processTouches(a, this.overDown))
                    },
                    overDown: function(a) {
                        R.set(a.pointerId, {
                            target: a.target,
                            out: a,
                            outTarget: a.target
                        }), u.enterOver(a), u.down(a)
                    },
                    touchmove: function(a) {
                        this.scrolling || (this.shouldScroll(a) ? (this.scrolling = !0, this.touchcancel(a)) : (a.preventDefault(), this.processTouches(a, this.moveOverOut)))
                    },
                    moveOverOut: function(a) {
                        var b = a,
                            c = R.get(b.pointerId);
                        if (c) {
                            var d = c.out,
                                e = c.outTarget;
                            u.move(b), d && e !== b.target && (d.relatedTarget = b.target, b.relatedTarget = e,
                                d.target = e, b.target ? (u.leaveOut(d), u.enterOver(b)) : (
                                    b.target = e, b.relatedTarget = null, this.cancelOut(b))), c.out = b, c.outTarget = b.target
                        }
                    },
                    touchend: function(a) {
                        this.dedupSynthMouse(a), this.processTouches(a, this.upOut)
                    },
                    upOut: function(a) {
                        this.scrolling || (u.up(a), u.leaveOut(a)), this.cleanUpPointer(a)
                    },
                    touchcancel: function(a) {
                        this.processTouches(a, this.cancelOut)
                    },
                    cancelOut: function(a) {
                        u.cancel(a), u.leaveOut(a), this.cleanUpPointer(a)
                    },
                    cleanUpPointer: function(a) {
                        R["delete"](a.pointerId), this.removePrimaryPointer(a)
                    },
                    dedupSynthMouse: function(a) {
                        var b = N.lastTouches,
                            c = a.changedTouches[0];
                        if (this.isPrimaryTouch(c)) {
                            var d = {
                                x: c.clientX,
                                y: c.clientY
                            };
                            b.push(d);
                            var e = function(a, b) {
                                var c = a.indexOf(b);
                                c > -1 && a.splice(c, 1)
                            }.bind(null, b, d);
                            setTimeout(e, S)
                        }
                    }
                };
            M = new c(V.elementAdded, V.elementRemoved, V.elementChanged, V);
            var W, X, Y, Z = u.pointermap,
                $ = window.MSPointerEvent && "number" == typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE,
                _ = {
                    events: ["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerOut", "MSPointerOver", "MSPointerCancel", "MSGotPointerCapture", "MSLostPointerCapture"],
                    register: function(a) {
                        u.listen(a, this.events)
                    },
                    unregister: function(a) {
                        u.unlisten(a, this.events)
                    },
                    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
                    prepareEvent: function(a) {
                        var b = a;
                        return $ && (b = u.cloneEvent(a), b.pointerType = this.POINTER_TYPES[a.pointerType]), b
                    },
                    cleanup: function(a) {
                        Z["delete"](a)
                    },
                    MSPointerDown: function(a) {
                        Z.set(a.pointerId, a);
                        var b = this.prepareEvent(a);
                        u.down(b)
                    },
                    MSPointerMove: function(a) {
                        var b = this.prepareEvent(a);
                        u.move(b)
                    },
                    MSPointerUp: function(a) {
                        var b = this.prepareEvent(a);
                        u.up(b), this.cleanup(a.pointerId)
                    },
                    MSPointerOut: function(a) {
                        var b = this.prepareEvent(a);
                        u.leaveOut(b)
                    },
                    MSPointerOver: function(a) {
                        var b = this.prepareEvent(a);
                        u.enterOver(b)
                    },
                    MSPointerCancel: function(a) {
                        var b = this.prepareEvent(a);
                        u.cancel(b), this.cleanup(a.pointerId)
                    },
                    MSLostPointerCapture: function(a) {
                        var b = u.makeEvent("lostpointercapture", a);
                        u.dispatchEvent(b)
                    },
                    MSGotPointerCapture: function(a) {
                        var b = u.makeEvent("gotpointercapture", a);
                        u.dispatchEvent(b)
                    }
                },
                aa = window.navigator;
            aa.msPointerEnabled ? (W = function(a) {
                i(a), j(this), k(a) && (u.setCapture(a, this, !0), this.msSetPointerCapture(a))
            }, X = function(a) {
                i(a), u.releaseCapture(a, !0), this.msReleasePointerCapture(a)
            }) : (W = function(a) {
                i(a), j(this), k(a) && u.setCapture(a, this)
            }, X = function(a) {
                i(a), u.releaseCapture(a)
            }), Y = function(a) {
                return !!u.captureInfo[a]
            }, g(), h(), l();
            var ba = {
                dispatcher: u,
                Installer: c,
                PointerEvent: a,
                PointerMap: p,
                targetFinding: v
            };
            return ba
        });

        ///////////////////////////////////////////////

        ///////////////////////////////////////////////
        var config = {
                "show_fabrication": false,
                "redraw_on_drag": true,
                "highlight_pin1": false,
                "extra_fields": [],
                "dark_mode": false,
                "bom_view": "left-right",
                "board_rotation": 0,
                "checkboxes": "Sourced,Placed",
                "show_silkscreen": true,
                "show_pads": true,
                "layer_view": "FB"
            }
            ///////////////////////////////////////////////

        ///////////////////////////////////////////////
        var pcbdata = JSON.parse(LZString.decompressFromBase64("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CywmXLLWyw2jLKum74zLKRqmI3rKBmpsrlBKm5qrlApmiLmbLZm1jV7KBmgct8AHqtWslKxyicpiaZyliocr2KlcuSakmtyudJv67yrlr47J0vabElONVbKzyzZsvKBm6Ergxky7NxVRHyopqmbsSt8tbK9Uwfy/KcyyppcaC1BMrd4yoBMtArRKiCshhCykKBjU4KsssjL6TQxQKa/wZstEr1DOUDKay9Zsuea8KgpsIqegUStIqegMpvWBByi+Coa6KmQAYrVDWJrOaEmpyqNL1Km5vNLd63Ooya2nESv7L6LYxSZauAGSpOb5K+ys5bLmtco3Lbm/lvSafK1jUMrjK18QTtwmjBqsqbK9loUrWKxyrlaeW1Jplr7mwarN1my1aporkqrgEKrBACKpKqYqg+virVMRKoOabWkACNqTarKpyq8q02rtbbW4quYboq8YudaKqouvdbcAGqs0AtqnapWauAfapjbOq9yu6ro606smKCZQctmaxq64omq3eYkCuqfiuatBLgm5aqgQtWjapjb74BqolYDGhNvVK2qpNqOq02kzAzaLq4Cuurri26vuqtWm6G+r0gN6o+qvqn6r+rwaoGpBqwahgEhroa3Ithr4axGvgAci5GrUBUai9hXa0mgStxr8auWqJq3gXtoxAKa4Ouprm8OmsQhGa8GrlrWa04C1bKoVQy5r5S3msVL+awWuQBha0WrxgJaqWo3azWg+oVqwmJWrPLVatao9bNa7Wt1r9aw2vSqrSs2otqKi62pNq7ayeudrXa92tNrPapwG9rUACDsDrg6+esXrG65+pbrk6jOo/qM67erub96yYoLqulfdtPqJ6h2u+Er6mutvq66huuXrCOteuTr36ruszrhcCjoyah69kpJrI2m6DPqRAcus0AZ63DpY776tjqfrm6zjrfrN67uq/qlWn+t/aj62jpAAxOi+qvrpOu+vw72OhTtfqN6j+pU6+OtTp/aqOv+oAa1auqFsBKAGUu2KlQZgoihgGiTEEA2AHJBSKQQT8Dej8QQgGgALa8OGqAdayyBAApAZoAAArTCGgBEAMABoAXgPdvyUIYqJAuyuC0IEQA+qg2rQBjIbVRABBaxABEBQgSyFPA2oHzuug/OyDAbBAu4LpAbhEMLvqBIuwQBi6KC+LsS6eQZLvySzKTOHS7qgTLuy6yCvLscVCu4r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"))
            ///////////////////////////////////////////////

        ///////////////////////////////////////////////
        /* Utility functions */

        var storagePrefix = 'KiCad_HTML_BOM__' + pcbdata.metadata.title + '__' +
            pcbdata.metadata.revision + '__#';
        var storage;

        function initStorage(key) {
            try {
                window.localStorage.getItem("blank");
                storage = window.localStorage;
            } catch (e) {
                // localStorage not available
            }
            if (!storage) {
                try {
                    window.sessionStorage.getItem("blank");
                    storage = window.sessionStorage;
                } catch (e) {
                    // sessionStorage also not available
                }
            }
        }

        function readStorage(key) {
            if (storage) {
                return storage.getItem(storagePrefix + key);
            } else {
                return null;
            }
        }

        function writeStorage(key, value) {
            if (storage) {
                storage.setItem(storagePrefix + key, value);
            }
        }

        function fancyDblClickHandler(el, onsingle, ondouble) {
            return function() {
                if (el.getAttribute("data-dblclick") == null) {
                    el.setAttribute("data-dblclick", 1);
                    setTimeout(function() {
                        if (el.getAttribute("data-dblclick") == 1) {
                            onsingle();
                        }
                        el.removeAttribute("data-dblclick");
                    }, 200);
                } else {
                    el.removeAttribute("data-dblclick");
                    ondouble();
                }
            }
        }

        function smoothScrollToRow(rowid) {
            document.getElementById(rowid).scrollIntoView({
                behavior: "smooth",
                block: "center",
                inline: "nearest"
            });
        }

        function focusInputField(input) {
            input.scrollIntoView(false);
            input.focus();
            input.select();
        }

        function copyToClipboard() {
            var text = '';
            for (var node of bomhead.childNodes[0].childNodes) {
                if (node.firstChild) {
                    text = text + node.firstChild.nodeValue;
                }
                if (node != bomhead.childNodes[0].lastChild) {
                    text += '\t';
                }
            }
            text += '\n';
            for (var row of bombody.childNodes) {
                for (var cell of row.childNodes) {
                    for (var node of cell.childNodes) {
                        if (node.nodeName == "INPUT") {
                            if (node.checked) {
                                text = text + '';
                            }
                        } else if (node.nodeName == "MARK") {
                            text = text + node.firstChild.nodeValue;
                        } else {
                            text = text + node.nodeValue;
                        }
                    }
                    if (cell != row.lastChild) {
                        text += '\t';
                    }
                }
                text += '\n';
            }
            var textArea = document.createElement("textarea");
            textArea.classList.add('clipboard-temp');
            textArea.value = text;

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                if (document.execCommand('copy')) {
                    console.log('Bom copied to clipboard.');
                }
            } catch (err) {
                console.log('Can not copy to clipboard.');
            }

            document.body.removeChild(textArea);
        }

        function removeGutterNode(node) {
            for (var i = 0; i < node.childNodes.length; i++) {
                if (node.childNodes[i].classList &&
                    node.childNodes[i].classList.contains("gutter")) {
                    node.removeChild(node.childNodes[i]);
                    break;
                }
            }
        }

        function cleanGutters() {
            removeGutterNode(document.getElementById("bot"));
            removeGutterNode(document.getElementById("canvasdiv"));
        }

        var units = {
            prefixes: {
                giga: ["G", "g", "giga", "Giga", "GIGA"],
                mega: ["M", "mega", "Mega", "MEGA"],
                kilo: ["K", "k", "kilo", "Kilo", "KILO"],
                milli: ["m", "milli", "Milli", "MILLI"],
                micro: ["U", "u", "micro", "Micro", "MICRO", "", ""], // different utf8 
                nano: ["N", "n", "nano", "Nano", "NANO"],
                pico: ["P", "p", "pico", "Pico", "PICO"],
            },
            unitsShort: ["R", "r", "", "F", "f", "H", "h"],
            unitsLong: [
                "OHM", "Ohm", "ohm", "ohms",
                "FARAD", "Farad", "farad",
                "HENRY", "Henry", "henry"
            ],
            getMultiplier: function(s) {
                if (this.prefixes.giga.includes(s)) return 1e9;
                if (this.prefixes.mega.includes(s)) return 1e6;
                if (this.prefixes.kilo.includes(s)) return 1e3;
                if (this.prefixes.milli.includes(s)) return 1e-3;
                if (this.prefixes.micro.includes(s)) return 1e-6;
                if (this.prefixes.nano.includes(s)) return 1e-9;
                if (this.prefixes.pico.includes(s)) return 1e-12;
                return 1;
            },
            valueRegex: null,
        }

        function initUtils() {
            var allPrefixes = units.prefixes.giga
                .concat(units.prefixes.mega)
                .concat(units.prefixes.kilo)
                .concat(units.prefixes.milli)
                .concat(units.prefixes.micro)
                .concat(units.prefixes.nano)
                .concat(units.prefixes.pico);
            var allUnits = units.unitsShort.concat(units.unitsLong);
            units.valueRegex = new RegExp("^([0-9\.]+)" +
                "\\s*(" + allPrefixes.join("|") + ")?" +
                "(" + allUnits.join("|") + ")?" +
                "(\\b.*)?$", "");
            units.valueAltRegex = new RegExp("^([0-9]*)" +
                "(" + units.unitsShort.join("|") + ")?" +
                "([GgMmKkUuNnPp])?" +
                "([0-9]*)" +
                "(\\b.*)?$", "");
            for (var bom_type of["both", "F", "B"]) {
                for (var row of pcbdata.bom[bom_type]) {
                    row.push(parseValue(row[1], row[3][0][0]));
                }
            }
        }

        function parseValue(val, ref) {
            var inferUnit = (unit, ref) => {
                if (unit) {
                    unit = unit.toLowerCase();
                    if (unit == '' || unit == "ohm" || unit == "ohms") {
                        unit = 'r';
                    }
                    unit = unit[0];
                } else {
                    ref = /^([a-z]+)\d+$/i.exec(ref);
                    if (ref) {
                        ref = ref[1].toLowerCase();
                        if (ref == "c") unit = 'f';
                        else if (ref == "l") unit = 'h';
                        else if (ref == "r" || ref == "rv") unit = 'r';
                        else unit = null;
                    }
                }
                return unit;
            };
            val = val.replace(/,/g, "");
            var match = units.valueRegex.exec(val);
            var unit;
            if (match) {
                val = parseFloat(match[1]);
                if (match[2]) {
                    val = val * units.getMultiplier(match[2]);
                }
                unit = inferUnit(match[3], ref);
                if (!unit) return null;
                else return {
                    val: val,
                    unit: unit,
                    extra: match[4],
                }
            }
            match = units.valueAltRegex.exec(val);
            if (match && (match[1] || match[4])) {
                val = parseFloat(match[1] + "." + match[4]);
                if (match[3]) {
                    val = val * units.getMultiplier(match[3]);
                }
                unit = inferUnit(match[2], ref);
                if (!unit) return null;
                else return {
                    val: val,
                    unit: unit,
                    extra: match[5],
                }
            }
            return null;
        }

        function valueCompare(a, b, stra, strb) {
            if (a === null && b === null) {
                // Failed to parse both values, compare them as strings.
                if (stra != strb) return stra > strb ? 1 : -1;
                else return 0;
            } else if (a === null) {
                return 1;
            } else if (b === null) {
                return -1;
            } else {
                if (a.unit != b.unit) return a.unit > b.unit ? 1 : -1;
                else if (a.val != b.val) return a.val > b.val ? 1 : -1;
                else if (a.extra != b.extra) return a.extra > b.extra ? 1 : -1;
                else return 0;
            }
        }

        function validateSaveImgDimension(element) {
            var valid = false;
            var intValue = 0;
            if (/^[1-9]\d*$/.test(element.value)) {
                intValue = parseInt(element.value);
                if (intValue <= 16000) {
                    valid = true;
                }
            }
            if (valid) {
                element.classList.remove("invalid");
            } else {
                element.classList.add("invalid");
            }
            return intValue;
        }

        function saveImage(layer) {
            var width = validateSaveImgDimension(document.getElementById("render-save-width"));
            var height = validateSaveImgDimension(document.getElementById("render-save-height"));
            var bgcolor = null;
            if (!document.getElementById("render-save-transparent").checked) {
                var style = getComputedStyle(topmostdiv);
                bgcolor = style.getPropertyValue("background-color");
            }
            if (!width || !height) return;

            // Prepare image
            var canvas = document.createElement("canvas");
            var layerdict = {
                    transform: {
                        x: 0,
                        y: 0,
                        s: 1,
                        panx: 0,
                        pany: 0,
                        zoom: 1,
                    },
                    bg: canvas,
                    fab: canvas,
                    silk: canvas,
                    highlight: canvas,
                    layer: layer,
                }
                // Do the rendering
            recalcLayerScale(layerdict, width, height);
            prepareLayer(layerdict);
            clearCanvas(canvas, bgcolor);
            drawBackground(layerdict, false);
            drawHighlightsOnLayer(layerdict, false);

            // Save image
            var imgdata = canvas.toDataURL("image/png");

            var filename = pcbdata.metadata.title;
            if (pcbdata.metadata.revision) {
                filename += `.${pcbdata.metadata.revision}`;
            }
            filename += `.${layer}.png`;
            saveFile(filename, dataURLtoBlob(imgdata));
        }

        function saveSettings() {
            var data = {
                type: "InteractiveHtmlBom settings",
                version: 1,
                pcbmetadata: pcbdata.metadata,
                settings: settings,
            }
            var blob = new Blob([JSON.stringify(data, null, 4)], {
                type: "application/json"
            });
            saveFile(`${pcbdata.metadata.title}.settings.json`, blob);
        }

        function loadSettings() {
            var input = document.createElement("input");
            input.type = "file";
            input.accept = ".settings.json";
            input.onchange = function(e) {
                var file = e.target.files[0];
                var reader = new FileReader();
                reader.onload = readerEvent => {
                    var content = readerEvent.target.result;
                    var newSettings;
                    try {
                        newSettings = JSON.parse(content);
                    } catch (e) {
                        alert("Selected file is not InteractiveHtmlBom settings file.");
                        return;
                    }
                    if (newSettings.type != "InteractiveHtmlBom settings") {
                        alert("Selected file is not InteractiveHtmlBom settings file.");
                        return;
                    }
                    var metadataMatches = newSettings.hasOwnProperty("pcbmetadata");
                    if (metadataMatches) {
                        for (var k in pcbdata.metadata) {
                            if (!newSettings.pcbmetadata.hasOwnProperty(k) || newSettings.pcbmetadata[k] != pcbdata.metadata[k]) {
                                metadataMatches = false;
                            }
                        }
                    }
                    if (!metadataMatches) {
                        var currentMetadata = JSON.stringify(pcbdata.metadata, null, 4);
                        var fileMetadata = JSON.stringify(newSettings.pcbmetadata, null, 4);
                        if (!confirm(
                                `Settins file metadata does not match current metadata.\n\n` +
                                `Page metadata:\n${currentMetadata}\n\n` +
                                `Settings file metadata:\n${fileMetadata}\n\n` +
                                `Press OK if you would like to import settings anyway.`)) {
                            return;
                        }
                    }
                    overwriteSettings(newSettings.settings);
                }
                reader.readAsText(file, 'UTF-8');
            }
            input.click();
        }

        function overwriteSettings(newSettings) {
            initDone = false;
            Object.assign(settings, newSettings);
            writeStorage("bomlayout", settings.bomlayout);
            writeStorage("bommode", settings.bommode);
            writeStorage("canvaslayout", settings.canvaslayout);
            writeStorage("bomCheckboxes", settings.checkboxes.join(","));
            document.getElementById("bomCheckboxes").value = settings.checkboxes.join(",");
            for (var checkbox of settings.checkboxes) {
                writeStorage("checkbox_" + checkbox, settings.checkboxStoredRefs[checkbox]);
            }
            writeStorage("darkenWhenChecked", settings.darkenWhenChecked);
            padsVisible(settings.renderPads);
            document.getElementById("padsCheckbox").checked = settings.renderPads;
            fabricationVisible(settings.renderFabrication);
            document.getElementById("fabricationCheckbox").checked = settings.renderFabrication;
            silkscreenVisible(settings.renderSilkscreen);
            document.getElementById("silkscreenCheckbox").checked = settings.renderSilkscreen;
            referencesVisible(settings.renderReferences);
            document.getElementById("referencesCheckbox").checked = settings.renderReferences;
            valuesVisible(settings.renderValues);
            document.getElementById("valuesCheckbox").checked = settings.renderValues;
            tracksVisible(settings.renderTracks);
            document.getElementById("tracksCheckbox").checked = settings.renderTracks;
            zonesVisible(settings.renderZones);
            document.getElementById("zonesCheckbox").checked = settings.renderZones;
            dnpOutline(settings.renderDnpOutline);
            document.getElementById("dnpOutlineCheckbox").checked = settings.renderDnpOutline;
            setRedrawOnDrag(settings.redrawOnDrag);
            document.getElementById("dragCheckbox").checked = settings.redrawOnDrag;
            setDarkMode(settings.darkMode);
            document.getElementById("darkmodeCheckbox").checked = settings.darkMode;
            setHighlightPin1(settings.highlightpin1);
            document.getElementById("highlightpin1Checkbox").checked = settings.highlightpin1;
            writeStorage("boardRotation", settings.boardRotation);
            document.getElementById("boardRotation").value = settings.boardRotation / 5;
            document.getElementById("rotationDegree").textContent = settings.boardRotation;
            initDone = true;
            prepCheckboxes();
            changeBomLayout(settings.bomlayout);
        }

        function saveFile(filename, blob) {
            var link = document.createElement("a");
            var objurl = URL.createObjectURL(blob);
            link.download = filename;
            link.href = objurl;
            link.click();
        }

        function dataURLtoBlob(dataurl) {
            var arr = dataurl.split(','),
                mime = arr[0].match(/:(.*?);/)[1],
                bstr = atob(arr[1]),
                n = bstr.length,
                u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], {
                type: mime
            });
        }

        var settings = {
            canvaslayout: "default",
            bomlayout: "default",
            bommode: "grouped",
            checkboxes: [],
            checkboxStoredRefs: {},
            darkMode: false,
            highlightpin1: false,
            redrawOnDrag: true,
            boardRotation: 0,
            renderPads: true,
            renderReferences: true,
            renderValues: true,
            renderSilkscreen: true,
            renderFabrication: true,
            renderDnpOutline: false,
            renderTracks: true,
            renderZones: true,
        }

        function initDefaults() {
            settings.bomlayout = readStorage("bomlayout");
            if (settings.bomlayout === null) {
                settings.bomlayout = config.bom_view;
            }
            if (!['bom-only', 'left-right', 'top-bottom'].includes(settings.bomlayout)) {
                settings.bomlayout = config.bom_view;
            }
            settings.bommode = readStorage("bommode");
            if (settings.bommode === null) {
                settings.bommode = "grouped";
            }
            if (!["grouped", "ungrouped", "netlist"].includes(settings.bommode)) {
                settings.bommode = "grouped";
            }
            settings.canvaslayout = readStorage("canvaslayout");
            if (settings.canvaslayout === null) {
                settings.canvaslayout = config.layer_view;
            }
            var bomCheckboxes = readStorage("bomCheckboxes");
            if (bomCheckboxes === null) {
                bomCheckboxes = config.checkboxes;
            }
            settings.checkboxes = bomCheckboxes.split(",").filter((e) => e);
            document.getElementById("bomCheckboxes").value = bomCheckboxes;

            settings.darkenWhenChecked = readStorage("darkenWhenChecked") || "";
            populateDarkenWhenCheckedOptions();

            function initBooleanSetting(storageString, def, elementId, func) {
                var b = readStorage(storageString);
                if (b === null) {
                    b = def;
                } else {
                    b = (b == "true");
                }
                document.getElementById(elementId).checked = b;
                func(b);
            }

            initBooleanSetting("padsVisible", config.show_pads, "padsCheckbox", padsVisible);
            initBooleanSetting("fabricationVisible", config.show_fabrication, "fabricationCheckbox", fabricationVisible);
            initBooleanSetting("silkscreenVisible", config.show_silkscreen, "silkscreenCheckbox", silkscreenVisible);
            initBooleanSetting("referencesVisible", true, "referencesCheckbox", referencesVisible);
            initBooleanSetting("valuesVisible", true, "valuesCheckbox", valuesVisible);
            if ("tracks" in pcbdata) {
                initBooleanSetting("tracksVisible", true, "tracksCheckbox", tracksVisible);
                initBooleanSetting("zonesVisible", true, "zonesCheckbox", zonesVisible);
            } else {
                document.getElementById("tracksAndZonesCheckboxes").style.display = "none";
                tracksVisible(false);
                zonesVisible(false);
            }
            initBooleanSetting("dnpOutline", false, "dnpOutlineCheckbox", dnpOutline);
            initBooleanSetting("redrawOnDrag", config.redraw_on_drag, "dragCheckbox", setRedrawOnDrag);
            initBooleanSetting("darkmode", config.dark_mode, "darkmodeCheckbox", setDarkMode);
            initBooleanSetting("highlightpin1", config.highlight_pin1, "highlightpin1Checkbox", setHighlightPin1);
            settings.boardRotation = readStorage("boardRotation");
            if (settings.boardRotation === null) {
                settings.boardRotation = config.board_rotation * 5;
            } else {
                settings.boardRotation = parseInt(settings.boardRotation);
            }
            document.getElementById("boardRotation").value = settings.boardRotation / 5;
            document.getElementById("rotationDegree").textContent = settings.boardRotation;
        }

        // Helper classes for user js callbacks.

        const IBOM_EVENT_TYPES = {
            ALL: "all",
            HIGHLIGHT_EVENT: "highlightEvent",
            CHECKBOX_CHANGE_EVENT: "checkboxChangeEvent",
            BOM_BODY_CHANGE_EVENT: "bomBodyChangeEvent",
        }

        const EventHandler = {
            callbacks: {},
            init: function() {
                for (eventType of Object.values(IBOM_EVENT_TYPES))
                    this.callbacks[eventType] = [];
            },
            registerCallback: function(eventType, callback) {
                this.callbacks[eventType].push(callback);
            },
            emitEvent: function(eventType, eventArgs) {
                event = {
                    eventType: eventType,
                    args: eventArgs,
                }
                var callback;
                for (callback of this.callbacks[eventType])
                    callback(event);
                for (callback of this.callbacks[IBOM_EVENT_TYPES.ALL])
                    callback(event);
            }
        }
        EventHandler.init();

        ///////////////////////////////////////////////

        ///////////////////////////////////////////////
        /* PCB rendering code */

        var emptyContext2d = document.createElement("canvas").getContext("2d");

        function deg2rad(deg) {
            return deg * Math.PI / 180;
        }

        function calcFontPoint(linepoint, text, offsetx, offsety, tilt) {
            var point = [
                linepoint[0] * text.width + offsetx,
                linepoint[1] * text.height + offsety
            ];
            // This approximates pcbnew behavior with how text tilts depending on horizontal justification
            point[0] -= (linepoint[1] + 0.5 * (1 + text.justify[0])) * text.height * tilt;
            return point;
        }

        function drawText(ctx, text, color) {
            if ("ref" in text && !settings.renderReferences) return;
            if ("val" in text && !settings.renderValues) return;
            ctx.save();
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.lineWidth = text.thickness;
            if ("svgpath" in text) {
                ctx.stroke(new Path2D(text.svgpath));
                ctx.restore();
                return;
            }
            ctx.translate(...text.pos);
            ctx.translate(text.thickness * 0.5, 0);
            var angle = -text.angle;
            if (text.attr.includes("mirrored")) {
                ctx.scale(-1, 1);
                angle = -angle;
            }
            var tilt = 0;
            if (text.attr.includes("italic")) {
                tilt = 0.125;
            }
            var interline = text.height * 1.5 + text.thickness;
            var txt = text.text.split("\n");
            // KiCad ignores last empty line.
            if (txt[txt.length - 1] == '') txt.pop();
            ctx.rotate(deg2rad(angle));
            var offsety = (1 - text.justify[1]) / 2 * text.height; // One line offset
            offsety -= (txt.length - 1) * (text.justify[1] + 1) / 2 * interline; // Multiline offset
            for (var i in txt) {
                var lineWidth = text.thickness + interline / 2 * tilt;
                for (var j = 0; j < txt[i].length; j++) {
                    if (txt[i][j] == '\t') {
                        var fourSpaces = 4 * pcbdata.font_data[' '].w * text.width;
                        lineWidth += fourSpaces - lineWidth % fourSpaces;
                    } else {
                        if (txt[i][j] == '~') {
                            j++;
                            if (j == txt[i].length)
                                break;
                        }
                        lineWidth += pcbdata.font_data[txt[i][j]].w * text.width;
                    }
                }
                var offsetx = -lineWidth * (text.justify[0] + 1) / 2;
                var inOverbar = false;
                for (var j = 0; j < txt[i].length; j++) {
                    if (txt[i][j] == '\t') {
                        var fourSpaces = 4 * pcbdata.font_data[' '].w * text.width;
                        offsetx += fourSpaces - offsetx % fourSpaces;
                        continue;
                    } else if (txt[i][j] == '~') {
                        j++;
                        if (j == txt[i].length)
                            break;
                        if (txt[i][j] != '~') {
                            inOverbar = !inOverbar;
                        }
                    }
                    var glyph = pcbdata.font_data[txt[i][j]];
                    if (inOverbar) {
                        var overbarStart = [offsetx, -text.height * 1.4 + offsety];
                        var overbarEnd = [offsetx + text.width * glyph.w, overbarStart[1]];

                        if (!lastHadOverbar) {
                            overbarStart[0] += text.height * 1.4 * tilt;
                            lastHadOverbar = true;
                        }
                        ctx.beginPath();
                        ctx.moveTo(...overbarStart);
                        ctx.lineTo(...overbarEnd);
                        ctx.stroke();
                    } else {
                        lastHadOverbar = false;
                    }
                    for (var line of glyph.l) {
                        ctx.beginPath();
                        ctx.moveTo(...calcFontPoint(line[0], text, offsetx, offsety, tilt));
                        for (var k = 1; k < line.length; k++) {
                            ctx.lineTo(...calcFontPoint(line[k], text, offsetx, offsety, tilt));
                        }
                        ctx.stroke();
                    }
                    offsetx += glyph.w * text.width;
                }
                offsety += interline;
            }
            ctx.restore();
        }

        function drawedge(ctx, scalefactor, edge, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = Math.max(1 / scalefactor, edge.width);
            ctx.lineCap = "round";
            if ("svgpath" in edge) {
                ctx.stroke(new Path2D(edge.svgpath));
            } else {
                ctx.beginPath();
                if (edge.type == "segment") {
                    ctx.moveTo(...edge.start);
                    ctx.lineTo(...edge.end);
                }
                if (edge.type == "rect") {
                    ctx.moveTo(...edge.start);
                    ctx.lineTo(edge.start[0], edge.end[1]);
                    ctx.lineTo(...edge.end);
                    ctx.lineTo(edge.end[0], edge.start[1]);
                    ctx.lineTo(...edge.start);
                }
                if (edge.type == "arc") {
                    ctx.arc(
                        ...edge.start,
                        edge.radius,
                        deg2rad(edge.startangle),
                        deg2rad(edge.endangle));
                }
                if (edge.type == "circle") {
                    ctx.arc(
                        ...edge.start,
                        edge.radius,
                        0, 2 * Math.PI);
                    ctx.closePath();
                }
                if (edge.type == "curve") {
                    ctx.moveTo(...edge.start);
                    ctx.bezierCurveTo(...edge.cpa, ...edge.cpb, ...edge.end);
                }
                ctx.stroke();
            }
        }

        function getChamferedRectPath(size, radius, chamfpos, chamfratio) {
            // chamfpos is a bitmask, left = 1, right = 2, bottom left = 4, bottom right = 8
            var path = new Path2D();
            var width = size[0];
            var height = size[1];
            var x = width * -0.5;
            var y = height * -0.5;
            var chamfOffset = Math.min(width, height) * chamfratio;
            path.moveTo(x, 0);
            if (chamfpos & 4) {
                path.lineTo(x, y + height - chamfOffset);
                path.lineTo(x + chamfOffset, y + height);
                path.lineTo(0, y + height);
            } else {
                path.arcTo(x, y + height, x + width, y + height, radius);
            }
            if (chamfpos & 8) {
                path.lineTo(x + width - chamfOffset, y + height);
                path.lineTo(x + width, y + height - chamfOffset);
                path.lineTo(x + width, 0);
            } else {
                path.arcTo(x + width, y + height, x + width, y, radius);
            }
            if (chamfpos & 2) {
                path.lineTo(x + width, y + chamfOffset);
                path.lineTo(x + width - chamfOffset, y);
                path.lineTo(0, y);
            } else {
                path.arcTo(x + width, y, x, y, radius);
            }
            if (chamfpos & 1) {
                path.lineTo(x + chamfOffset, y);
                path.lineTo(x, y + chamfOffset);
                path.lineTo(x, 0);
            } else {
                path.arcTo(x, y, x, y + height, radius);
            }
            path.closePath();
            return path;
        }

        function getOblongPath(size) {
            return getChamferedRectPath(size, Math.min(size[0], size[1]) / 2, 0, 0);
        }

        function getPolygonsPath(shape) {
            if (shape.path2d) {
                return shape.path2d;
            }
            if ("svgpath" in shape) {
                shape.path2d = new Path2D(shape.svgpath);
            } else {
                var path = new Path2D();
                for (var polygon of shape.polygons) {
                    path.moveTo(...polygon[0]);
                    for (var i = 1; i < polygon.length; i++) {
                        path.lineTo(...polygon[i]);
                    }
                    path.closePath();
                }
                shape.path2d = path;
            }
            return shape.path2d;
        }

        function drawPolygonShape(ctx, shape, color) {
            ctx.save();
            ctx.fillStyle = color;
            if (!("svgpath" in shape)) {
                ctx.translate(...shape.pos);
                ctx.rotate(deg2rad(-shape.angle));
            }
            ctx.fill(getPolygonsPath(shape));
            ctx.restore();
        }

        function drawDrawing(ctx, scalefactor, drawing, color) {
            if (["segment", "arc", "circle", "curve"].includes(drawing.type)) {
                drawedge(ctx, scalefactor, drawing, color);
            } else if (drawing.type == "polygon") {
                drawPolygonShape(ctx, drawing, color);
            } else {
                drawText(ctx, drawing, color);
            }
        }

        function getCirclePath(radius) {
            var path = new Path2D();
            path.arc(0, 0, radius, 0, 2 * Math.PI);
            path.closePath();
            return path;
        }

        function getCachedPadPath(pad) {
            if (!pad.path2d) {
                // if path2d is not set, build one and cache it on pad object
                if (pad.shape == "rect") {
                    pad.path2d = new Path2D();
                    pad.path2d.rect(...pad.size.map(c => -c * 0.5), ...pad.size);
                } else if (pad.shape == "oval") {
                    pad.path2d = getOblongPath(pad.size);
                } else if (pad.shape == "circle") {
                    pad.path2d = getCirclePath(pad.size[0] / 2);
                } else if (pad.shape == "roundrect") {
                    pad.path2d = getChamferedRectPath(pad.size, pad.radius, 0, 0);
                } else if (pad.shape == "chamfrect") {
                    pad.path2d = getChamferedRectPath(pad.size, pad.radius, pad.chamfpos, pad.chamfratio)
                } else if (pad.shape == "custom") {
                    pad.path2d = getPolygonsPath(pad);
                }
            }
            return pad.path2d;
        }

        function drawPad(ctx, pad, color, outline, hole) {
            ctx.save();
            ctx.translate(...pad.pos);
            ctx.rotate(deg2rad(pad.angle));
            if (pad.offset) {
                ctx.translate(...pad.offset);
            }
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            var path = getCachedPadPath(pad);
            if (outline) {
                ctx.stroke(path);
            } else {
                ctx.fill(path);
            }
            if (pad.type == "th" && hole) {
                if (pad.offset) {
                    ctx.translate(-pad.offset[0], -pad.offset[1]);
                }
                ctx.fillStyle = "#CCCCCC";
                if (pad.drillshape == "oblong") {
                    ctx.fill(getOblongPath(pad.drillsize));
                } else {
                    ctx.fill(getCirclePath(pad.drillsize[0] / 2));
                }
            }
            ctx.restore();
        }

        function drawFootprint(ctx, layer, scalefactor, footprint, padcolor, outlinecolor, highlight, outline) {
            if (highlight) {
                // draw bounding box
                if (footprint.layer == layer) {
                    ctx.save();
                    ctx.globalAlpha = 0.2;
                    ctx.translate(...footprint.bbox.pos);
                    ctx.rotate(deg2rad(-footprint.bbox.angle));
                    ctx.translate(...footprint.bbox.relpos);
                    ctx.fillStyle = padcolor;
                    ctx.fillRect(0, 0, ...footprint.bbox.size);
                    ctx.globalAlpha = 1;
                    ctx.strokeStyle = padcolor;
                    ctx.strokeRect(0, 0, ...footprint.bbox.size);
                    ctx.restore();
                }
            }
            // draw drawings
            for (var drawing of footprint.drawings) {
                if (drawing.layer == layer) {
                    drawDrawing(ctx, scalefactor, drawing.drawing, padcolor);
                }
            }
            // draw pads
            if (settings.renderPads) {
                for (var pad of footprint.pads) {
                    if (pad.layers.includes(layer)) {
                        drawPad(ctx, pad, padcolor, outline, true);
                        if (pad.pin1 && settings.highlightpin1) {
                            drawPad(ctx, pad, outlinecolor, true, false);
                        }
                    }
                }
            }
        }

        function drawEdgeCuts(canvas, scalefactor) {
            var ctx = canvas.getContext("2d");
            var edgecolor = getComputedStyle(topmostdiv).getPropertyValue('--pcb-edge-color');
            for (var edge of pcbdata.edges) {
                drawedge(ctx, scalefactor, edge, edgecolor);
            }
        }

        function drawFootprints(canvas, layer, scalefactor, highlight) {
            var ctx = canvas.getContext("2d");
            ctx.lineWidth = 3 / scalefactor;
            var style = getComputedStyle(topmostdiv);
            var padcolor = style.getPropertyValue('--pad-color');
            var outlinecolor = style.getPropertyValue('--pin1-outline-color');
            if (highlight) {
                padcolor = style.getPropertyValue('--pad-color-highlight');
                outlinecolor = style.getPropertyValue('--pin1-outline-color-highlight');
            }
            for (var i = 0; i < pcbdata.footprints.length; i++) {
                var mod = pcbdata.footprints[i];
                var outline = settings.renderDnpOutline && pcbdata.bom.skipped.includes(i);
                if (!highlight || highlightedFootprints.includes(i)) {
                    drawFootprint(ctx, layer, scalefactor, mod, padcolor, outlinecolor, highlight, outline);
                }
            }
        }

        function drawBgLayer(layername, canvas, layer, scalefactor, edgeColor, polygonColor, textColor) {
            var ctx = canvas.getContext("2d");
            for (var d of pcbdata[layername][layer]) {
                if (["segment", "arc", "circle", "curve", "rect"].includes(d.type)) {
                    drawedge(ctx, scalefactor, d, edgeColor);
                } else if (d.type == "polygon") {
                    drawPolygonShape(ctx, d, polygonColor);
                } else {
                    drawText(ctx, d, textColor);
                }
            }
        }

        function drawTracks(canvas, layer, color, highlight) {
            ctx = canvas.getContext("2d");
            ctx.strokeStyle = color;
            ctx.lineCap = "round";
            for (var track of pcbdata.tracks[layer]) {
                if (highlight && highlightedNet != track.net) continue;
                ctx.lineWidth = track.width;
                ctx.beginPath();
                ctx.moveTo(...track.start);
                ctx.lineTo(...track.end);
                ctx.stroke();
            }
        }

        function drawZones(canvas, layer, color, highlight) {
            ctx = canvas.getContext("2d");
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineJoin = "round";
            for (var zone of pcbdata.zones[layer]) {
                if (!zone.path2d) {
                    zone.path2d = getPolygonsPath(zone);
                }
                if (highlight && highlightedNet != zone.net) continue;
                ctx.fill(zone.path2d);
                if (zone.width > 0) {
                    ctx.lineWidth = zone.width;
                    ctx.stroke(zone.path2d);
                }
            }
        }

        function clearCanvas(canvas, color = null) {
            var ctx = canvas.getContext("2d");
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            if (color) {
                ctx.fillStyle = color;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            ctx.restore();
        }

        function drawNets(canvas, layer, highlight) {
            var style = getComputedStyle(topmostdiv);
            if (settings.renderTracks) {
                var trackColor = style.getPropertyValue(highlight ? '--track-color-highlight' : '--track-color');
                drawTracks(canvas, layer, trackColor, highlight);
            }
            if (settings.renderZones) {
                var zoneColor = style.getPropertyValue(highlight ? '--zone-color-highlight' : '--zone-color');
                drawZones(canvas, layer, zoneColor, highlight);
            }
            if (highlight && settings.renderPads) {
                var padColor = style.getPropertyValue('--pad-color-highlight');
                var ctx = canvas.getContext("2d");
                for (var footprint of pcbdata.footprints) {
                    // draw pads
                    for (var pad of footprint.pads) {
                        if (highlightedNet != pad.net) continue;
                        if (pad.layers.includes(layer)) {
                            drawPad(ctx, pad, padColor, false, true);
                        }
                    }
                }
            }
        }

        function drawHighlightsOnLayer(canvasdict, clear = true) {
            if (clear) {
                clearCanvas(canvasdict.highlight);
            }
            if (highlightedFootprints.length > 0) {
                drawFootprints(canvasdict.highlight, canvasdict.layer,
                    canvasdict.transform.s * canvasdict.transform.zoom, true);
            }
            if (highlightedNet !== null) {
                drawNets(canvasdict.highlight, canvasdict.layer, true);
            }
        }

        function drawHighlights() {
            drawHighlightsOnLayer(allcanvas.front);
            drawHighlightsOnLayer(allcanvas.back);
        }

        function drawBackground(canvasdict, clear = true) {
            if (clear) {
                clearCanvas(canvasdict.bg);
                clearCanvas(canvasdict.fab);
                clearCanvas(canvasdict.silk);
            }

            drawNets(canvasdict.bg, canvasdict.layer, false);
            drawFootprints(canvasdict.bg, canvasdict.layer,
                canvasdict.transform.s * canvasdict.transform.zoom, false);

            drawEdgeCuts(canvasdict.bg, canvasdict.transform.s);

            var style = getComputedStyle(topmostdiv);
            var edgeColor = style.getPropertyValue('--silkscreen-edge-color');
            var polygonColor = style.getPropertyValue('--silkscreen-polygon-color');
            var textColor = style.getPropertyValue('--silkscreen-text-color');
            if (settings.renderSilkscreen) {
                drawBgLayer(
                    "silkscreen", canvasdict.silk, canvasdict.layer,
                    canvasdict.transform.s * canvasdict.transform.zoom,
                    edgeColor, polygonColor, textColor);
            }
            edgeColor = style.getPropertyValue('--fabrication-edge-color');
            polygonColor = style.getPropertyValue('--fabrication-polygon-color');
            textColor = style.getPropertyValue('--fabrication-text-color');
            if (settings.renderFabrication) {
                drawBgLayer(
                    "fabrication", canvasdict.fab, canvasdict.layer,
                    canvasdict.transform.s * canvasdict.transform.zoom,
                    edgeColor, polygonColor, textColor);
            }
        }

        function prepareCanvas(canvas, flip, transform) {
            var ctx = canvas.getContext("2d");
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            var fontsize = 1.55;
            ctx.scale(transform.zoom, transform.zoom);
            ctx.translate(transform.panx, transform.pany);
            if (flip) {
                ctx.scale(-1, 1);
            }
            ctx.translate(transform.x, transform.y);
            ctx.rotate(deg2rad(settings.boardRotation));
            ctx.scale(transform.s, transform.s);
        }

        function prepareLayer(canvasdict) {
            var flip = (canvasdict.layer == "B");
            for (var c of["bg", "fab", "silk", "highlight"]) {
                prepareCanvas(canvasdict[c], flip, canvasdict.transform);
            }
        }

        function rotateVector(v, angle) {
            angle = deg2rad(angle);
            return [
                v[0] * Math.cos(angle) - v[1] * Math.sin(angle),
                v[0] * Math.sin(angle) + v[1] * Math.cos(angle)
            ];
        }

        function applyRotation(bbox) {
            var corners = [
                [bbox.minx, bbox.miny],
                [bbox.minx, bbox.maxy],
                [bbox.maxx, bbox.miny],
                [bbox.maxx, bbox.maxy],
            ];
            corners = corners.map((v) => rotateVector(v, settings.boardRotation));
            return {
                minx: corners.reduce((a, v) => Math.min(a, v[0]), Infinity),
                miny: corners.reduce((a, v) => Math.min(a, v[1]), Infinity),
                maxx: corners.reduce((a, v) => Math.max(a, v[0]), -Infinity),
                maxy: corners.reduce((a, v) => Math.max(a, v[1]), -Infinity),
            }
        }

        function recalcLayerScale(layerdict, width, height) {
            var bbox = applyRotation(pcbdata.edges_bbox);
            var scalefactor = 0.98 * Math.min(
                width / (bbox.maxx - bbox.minx),
                height / (bbox.maxy - bbox.miny)
            );
            if (scalefactor < 0.1) {
                scalefactor = 1;
            }
            layerdict.transform.s = scalefactor;
            var flip = (layerdict.layer == "B");
            if (flip) {
                layerdict.transform.x = -((bbox.maxx + bbox.minx) * scalefactor + width) * 0.5;
            } else {
                layerdict.transform.x = -((bbox.maxx + bbox.minx) * scalefactor - width) * 0.5;
            }
            layerdict.transform.y = -((bbox.maxy + bbox.miny) * scalefactor - height) * 0.5;
            for (var c of["bg", "fab", "silk", "highlight"]) {
                canvas = layerdict[c];
                canvas.width = width;
                canvas.height = height;
                canvas.style.width = (width / devicePixelRatio) + "px";
                canvas.style.height = (height / devicePixelRatio) + "px";
            }
        }

        function redrawCanvas(layerdict) {
            prepareLayer(layerdict);
            drawBackground(layerdict);
            drawHighlightsOnLayer(layerdict);
        }

        function resizeCanvas(layerdict) {
            var canvasdivid = {
                "F": "frontcanvas",
                "B": "backcanvas"
            }[layerdict.layer];
            var width = document.getElementById(canvasdivid).clientWidth * devicePixelRatio;
            var height = document.getElementById(canvasdivid).clientHeight * devicePixelRatio;
            recalcLayerScale(layerdict, width, height);
            redrawCanvas(layerdict);
        }

        function resizeAll() {
            resizeCanvas(allcanvas.front);
            resizeCanvas(allcanvas.back);
        }

        function pointWithinDistanceToSegment(x, y, x1, y1, x2, y2, d) {
            var A = x - x1;
            var B = y - y1;
            var C = x2 - x1;
            var D = y2 - y1;

            var dot = A * C + B * D;
            var len_sq = C * C + D * D;
            var dx, dy;
            if (len_sq == 0) {
                // start and end of the segment coincide
                dx = x - x1;
                dy = y - y1;
            } else {
                var param = dot / len_sq;
                var xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                dx = x - xx;
                dy = y - yy;
            }
            return dx * dx + dy * dy <= d * d;
        }

        function pointWithinPad(x, y, pad) {
            var v = [x - pad.pos[0], y - pad.pos[1]];
            v = rotateVector(v, -pad.angle);
            if (pad.offset) {
                v[0] -= pad.offset[0];
                v[1] -= pad.offset[1];
            }
            return emptyContext2d.isPointInPath(getCachedPadPath(pad), ...v);
        }

        function netHitScan(layer, x, y) {
            // Check track segments
            if (settings.renderTracks && pcbdata.tracks) {
                for (var track of pcbdata.tracks[layer]) {
                    if (pointWithinDistanceToSegment(x, y, ...track.start, ...track.end, track.width / 2)) {
                        return track.net;
                    }
                }
            }
            // Check pads
            if (settings.renderPads) {
                for (var footprint of pcbdata.footprints) {
                    for (var pad of footprint.pads) {
                        if (pad.layers.includes(layer) && pointWithinPad(x, y, pad)) {
                            return pad.net;
                        }
                    }
                }
            }
            return null;
        }

        function pointWithinFootprintBbox(x, y, bbox) {
            var v = [x - bbox.pos[0], y - bbox.pos[1]];
            v = rotateVector(v, bbox.angle);
            return bbox.relpos[0] <= v[0] && v[0] <= bbox.relpos[0] + bbox.size[0] &&
                bbox.relpos[1] <= v[1] && v[1] <= bbox.relpos[1] + bbox.size[1];
        }

        function bboxHitScan(layer, x, y) {
            var result = [];
            for (var i = 0; i < pcbdata.footprints.length; i++) {
                var footprint = pcbdata.footprints[i];
                if (footprint.layer == layer) {
                    if (pointWithinFootprintBbox(x, y, footprint.bbox)) {
                        result.push(i);
                    }
                }
            }
            return result;
        }

        function handlePointerDown(e, layerdict) {
            if (e.button != 0 && e.button != 1) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();

            if (!e.hasOwnProperty("offsetX")) {
                // The polyfill doesn't set this properly
                e.offsetX = e.pageX - e.currentTarget.offsetLeft;
                e.offsetY = e.pageY - e.currentTarget.offsetTop;
            }

            layerdict.pointerStates[e.pointerId] = {
                distanceTravelled: 0,
                lastX: e.offsetX,
                lastY: e.offsetY,
                downTime: Date.now(),
            };
        }

        function handleMouseClick(e, layerdict) {
            if (!e.hasOwnProperty("offsetX")) {
                // The polyfill doesn't set this properly
                e.offsetX = e.pageX - e.currentTarget.offsetLeft;
                e.offsetY = e.pageY - e.currentTarget.offsetTop;
            }

            var x = e.offsetX;
            var y = e.offsetY;
            var t = layerdict.transform;
            if (layerdict.layer == "B") {
                x = (devicePixelRatio * x / t.zoom - t.panx + t.x) / -t.s;
            } else {
                x = (devicePixelRatio * x / t.zoom - t.panx - t.x) / t.s;
            }
            y = (devicePixelRatio * y / t.zoom - t.y - t.pany) / t.s;
            var v = rotateVector([x, y], -settings.boardRotation);
            if ("nets" in pcbdata) {
                var net = netHitScan(layerdict.layer, ...v);
                if (net !== highlightedNet) {
                    netClicked(net);
                }
            }
            if (highlightedNet === null) {
                var footprints = bboxHitScan(layerdict.layer, ...v);
                if (footprints.length > 0) {
                    footprintsClicked(footprints);
                }
            }
        }

        function handlePointerLeave(e, layerdict) {
            e.preventDefault();
            e.stopPropagation();

            if (!settings.redrawOnDrag) {
                redrawCanvas(layerdict);
            }

            delete layerdict.pointerStates[e.pointerId];
        }

        function resetTransform(layerdict) {
            layerdict.transform.panx = 0;
            layerdict.transform.pany = 0;
            layerdict.transform.zoom = 1;
            redrawCanvas(layerdict);
        }

        function handlePointerUp(e, layerdict) {
            if (!e.hasOwnProperty("offsetX")) {
                // The polyfill doesn't set this properly
                e.offsetX = e.pageX - e.currentTarget.offsetLeft;
                e.offsetY = e.pageY - e.currentTarget.offsetTop;
            }

            e.preventDefault();
            e.stopPropagation();

            if (e.button == 2) {
                // Reset pan and zoom on right click.
                resetTransform(layerdict);
                layerdict.anotherPointerTapped = false;
                return;
            }

            // We haven't necessarily had a pointermove event since the interaction started, so make sure we update this now
            var ptr = layerdict.pointerStates[e.pointerId];
            ptr.distanceTravelled += Math.abs(e.offsetX - ptr.lastX) + Math.abs(e.offsetY - ptr.lastY);

            if (e.button == 0 && ptr.distanceTravelled < 10 && Date.now() - ptr.downTime <= 500) {
                if (Object.keys(layerdict.pointerStates).length == 1) {
                    if (layerdict.anotherPointerTapped) {
                        // This is the second pointer coming off of a two-finger tap
                        resetTransform(layerdict);
                    } else {
                        // This is just a regular tap
                        handleMouseClick(e, layerdict);
                    }
                    layerdict.anotherPointerTapped = false;
                } else {
                    // This is the first finger coming off of what could become a two-finger tap
                    layerdict.anotherPointerTapped = true;
                }
            } else {
                if (!settings.redrawOnDrag) {
                    redrawCanvas(layerdict);
                }
                layerdict.anotherPointerTapped = false;
            }

            delete layerdict.pointerStates[e.pointerId];
        }

        function handlePointerMove(e, layerdict) {
            if (!layerdict.pointerStates.hasOwnProperty(e.pointerId)) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();

            if (!e.hasOwnProperty("offsetX")) {
                // The polyfill doesn't set this properly
                e.offsetX = e.pageX - e.currentTarget.offsetLeft;
                e.offsetY = e.pageY - e.currentTarget.offsetTop;
            }

            var thisPtr = layerdict.pointerStates[e.pointerId];

            var dx = e.offsetX - thisPtr.lastX;
            var dy = e.offsetY - thisPtr.lastY;

            // If this number is low on pointer up, we count the action as a click
            thisPtr.distanceTravelled += Math.abs(dx) + Math.abs(dy);

            if (Object.keys(layerdict.pointerStates).length == 1) {
                // This is a simple drag
                layerdict.transform.panx += devicePixelRatio * dx / layerdict.transform.zoom;
                layerdict.transform.pany += devicePixelRatio * dy / layerdict.transform.zoom;
            } else if (Object.keys(layerdict.pointerStates).length == 2) {
                var otherPtr = Object.values(layerdict.pointerStates).filter((ptr) => ptr != thisPtr)[0];

                var oldDist = Math.sqrt(Math.pow(thisPtr.lastX - otherPtr.lastX, 2) + Math.pow(thisPtr.lastY - otherPtr.lastY, 2));
                var newDist = Math.sqrt(Math.pow(e.offsetX - otherPtr.lastX, 2) + Math.pow(e.offsetY - otherPtr.lastY, 2));

                var scaleFactor = newDist / oldDist;

                if (scaleFactor != NaN) {
                    layerdict.transform.zoom *= scaleFactor;

                    var zoomd = (1 - scaleFactor) / layerdict.transform.zoom;
                    layerdict.transform.panx += devicePixelRatio * otherPtr.lastX * zoomd;
                    layerdict.transform.pany += devicePixelRatio * otherPtr.lastY * zoomd;
                }
            }

            thisPtr.lastX = e.offsetX;
            thisPtr.lastY = e.offsetY;

            if (settings.redrawOnDrag) {
                redrawCanvas(layerdict);
            }
        }

        function handleMouseWheel(e, layerdict) {
            e.preventDefault();
            e.stopPropagation();
            var t = layerdict.transform;
            var wheeldelta = e.deltaY;
            if (e.deltaMode == 1) {
                // FF only, scroll by lines
                wheeldelta *= 30;
            } else if (e.deltaMode == 2) {
                wheeldelta *= 300;
            }
            var m = Math.pow(1.1, -wheeldelta / 40);
            // Limit amount of zoom per tick.
            if (m > 2) {
                m = 2;
            } else if (m < 0.5) {
                m = 0.5;
            }
            t.zoom *= m;
            var zoomd = (1 - m) / t.zoom;
            t.panx += devicePixelRatio * e.offsetX * zoomd;
            t.pany += devicePixelRatio * e.offsetY * zoomd;
            redrawCanvas(layerdict);
        }

        function addMouseHandlers(div, layerdict) {
            div.addEventListener("pointerdown", function(e) {
                handlePointerDown(e, layerdict);
            });
            div.addEventListener("pointermove", function(e) {
                handlePointerMove(e, layerdict);
            });
            div.addEventListener("pointerup", function(e) {
                handlePointerUp(e, layerdict);
            });
            var pointerleave = function(e) {
                handlePointerLeave(e, layerdict);
            }
            div.addEventListener("pointercancel", pointerleave);
            div.addEventListener("pointerleave", pointerleave);
            div.addEventListener("pointerout", pointerleave);

            div.onwheel = function(e) {
                handleMouseWheel(e, layerdict);
            }
            for (var element of[div, layerdict.bg, layerdict.fab, layerdict.silk, layerdict.highlight]) {
                element.addEventListener("contextmenu", function(e) {
                    e.preventDefault();
                }, false);
            }
        }

        function setRedrawOnDrag(value) {
            settings.redrawOnDrag = value;
            writeStorage("redrawOnDrag", value);
        }

        function setBoardRotation(value) {
            settings.boardRotation = value * 5;
            writeStorage("boardRotation", settings.boardRotation);
            document.getElementById("rotationDegree").textContent = settings.boardRotation;
            resizeAll();
        }

        function initRender() {
            allcanvas = {
                front: {
                    transform: {
                        x: 0,
                        y: 0,
                        s: 1,
                        panx: 0,
                        pany: 0,
                        zoom: 1,
                    },
                    pointerStates: {},
                    anotherPointerTapped: false,
                    bg: document.getElementById("F_bg"),
                    fab: document.getElementById("F_fab"),
                    silk: document.getElementById("F_slk"),
                    highlight: document.getElementById("F_hl"),
                    layer: "F",
                },
                back: {
                    transform: {
                        x: 0,
                        y: 0,
                        s: 1,
                        panx: 0,
                        pany: 0,
                        zoom: 1,
                    },
                    pointerStates: {},
                    anotherPointerTapped: false,
                    bg: document.getElementById("B_bg"),
                    fab: document.getElementById("B_fab"),
                    silk: document.getElementById("B_slk"),
                    highlight: document.getElementById("B_hl"),
                    layer: "B",
                }
            };
            addMouseHandlers(document.getElementById("frontcanvas"), allcanvas.front);
            addMouseHandlers(document.getElementById("backcanvas"), allcanvas.back);
        }

        ///////////////////////////////////////////////

        ///////////////////////////////////////////////
        /* DOM manipulation and misc code */

        var bomsplit;
        var canvassplit;
        var initDone = false;
        var bomSortFunction = null;
        var currentSortColumn = null;
        var currentSortOrder = null;
        var currentHighlightedRowId;
        var highlightHandlers = [];
        var footprintIndexToHandler = {};
        var netsToHandler = {};
        var highlightedFootprints = [];
        var highlightedNet = null;
        var lastClicked;

        function dbg(html) {
            dbgdiv.innerHTML = html;
        }

        function redrawIfInitDone() {
            if (initDone) {
                redrawCanvas(allcanvas.front);
                redrawCanvas(allcanvas.back);
            }
        }

        function padsVisible(value) {
            writeStorage("padsVisible", value);
            settings.renderPads = value;
            redrawIfInitDone();
        }

        function referencesVisible(value) {
            writeStorage("referencesVisible", value);
            settings.renderReferences = value;
            redrawIfInitDone();
        }

        function valuesVisible(value) {
            writeStorage("valuesVisible", value);
            settings.renderValues = value;
            redrawIfInitDone();
        }

        function tracksVisible(value) {
            writeStorage("tracksVisible", value);
            settings.renderTracks = value;
            redrawIfInitDone();
        }

        function zonesVisible(value) {
            writeStorage("zonesVisible", value);
            settings.renderZones = value;
            redrawIfInitDone();
        }

        function dnpOutline(value) {
            writeStorage("dnpOutline", value);
            settings.renderDnpOutline = value;
            redrawIfInitDone();
        }

        function setDarkMode(value) {
            if (value) {
                topmostdiv.classList.add("dark");
            } else {
                topmostdiv.classList.remove("dark");
            }
            writeStorage("darkmode", value);
            settings.darkMode = value;
            redrawIfInitDone();
        }

        function setFullscreen(value) {
            if (value) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function fabricationVisible(value) {
            writeStorage("fabricationVisible", value);
            settings.renderFabrication = value;
            redrawIfInitDone();
        }

        function silkscreenVisible(value) {
            writeStorage("silkscreenVisible", value);
            settings.renderSilkscreen = value;
            redrawIfInitDone();
        }

        function setHighlightPin1(value) {
            writeStorage("highlightpin1", value);
            settings.highlightpin1 = value;
            redrawIfInitDone();
        }

        function getStoredCheckboxRefs(checkbox) {
            function convert(ref) {
                var intref = parseInt(ref);
                if (isNaN(intref)) {
                    for (var i = 0; i < pcbdata.footprints.length; i++) {
                        if (pcbdata.footprints[i].ref == ref) {
                            return i;
                        }
                    }
                    return -1;
                } else {
                    return intref;
                }
            }
            if (!(checkbox in settings.checkboxStoredRefs)) {
                var val = readStorage("checkbox_" + checkbox);
                settings.checkboxStoredRefs[checkbox] = val ? val : "";
            }
            if (!settings.checkboxStoredRefs[checkbox]) {
                return new Set();
            } else {
                return new Set(settings.checkboxStoredRefs[checkbox].split(",").map(r => convert(r)).filter(a => a >= 0));
            }
        }

        function getCheckboxState(checkbox, references) {
            var storedRefsSet = getStoredCheckboxRefs(checkbox);
            var currentRefsSet = new Set(references.map(r => r[1]));
            // Get difference of current - stored
            var difference = new Set(currentRefsSet);
            for (ref of storedRefsSet) {
                difference.delete(ref);
            }
            if (difference.size == 0) {
                // All the current refs are stored
                return "checked";
            } else if (difference.size == currentRefsSet.size) {
                // None of the current refs are stored
                return "unchecked";
            } else {
                // Some of the refs are stored
                return "indeterminate";
            }
        }

        function setBomCheckboxState(checkbox, element, references) {
            var state = getCheckboxState(checkbox, references);
            element.checked = (state == "checked");
            element.indeterminate = (state == "indeterminate");
        }

        function createCheckboxChangeHandler(checkbox, references, row) {
            return function() {
                refsSet = getStoredCheckboxRefs(checkbox);
                var darkenWhenChecked = settings.darkenWhenChecked == checkbox;
                eventArgs = {
                    checkbox: checkbox,
                    refs: references,
                }
                if (this.checked) {
                    // checkbox ticked
                    for (var ref of references) {
                        refsSet.add(ref[1]);
                    }
                    if (darkenWhenChecked) {
                        row.classList.add("checked");
                    }
                    eventArgs.state = 'checked';
                } else {
                    // checkbox unticked
                    for (var ref of references) {
                        refsSet.delete(ref[1]);
                    }
                    if (darkenWhenChecked) {
                        row.classList.remove("checked");
                    }
                    eventArgs.state = 'unchecked';
                }
                settings.checkboxStoredRefs[checkbox] = [...refsSet].join(",");
                writeStorage("checkbox_" + checkbox, settings.checkboxStoredRefs[checkbox]);
                updateCheckboxStats(checkbox);
                EventHandler.emitEvent(IBOM_EVENT_TYPES.CHECKBOX_CHANGE_EVENT, eventArgs);
            }
        }

        function clearHighlightedFootprints() {
            if (currentHighlightedRowId) {
                document.getElementById(currentHighlightedRowId).classList.remove("highlighted");
                currentHighlightedRowId = null;
                highlightedFootprints = [];
                highlightedNet = null;
            }
        }

        function createRowHighlightHandler(rowid, refs, net) {
            return function() {
                if (currentHighlightedRowId) {
                    if (currentHighlightedRowId == rowid) {
                        return;
                    }
                    document.getElementById(currentHighlightedRowId).classList.remove("highlighted");
                }
                document.getElementById(rowid).classList.add("highlighted");
                currentHighlightedRowId = rowid;
                highlightedFootprints = refs ? refs.map(r => r[1]) : [];
                highlightedNet = net;
                drawHighlights();
                EventHandler.emitEvent(
                    IBOM_EVENT_TYPES.HIGHLIGHT_EVENT, {
                        rowid: rowid,
                        refs: refs,
                        net: net
                    });
            }
        }

        function entryMatches(entry) {
            if (settings.bommode == "netlist") {
                // entry is just a net name
                return entry.toLowerCase().indexOf(filter) >= 0;
            }
            // check refs
            for (var ref of entry[3]) {
                if (ref[0].toLowerCase().indexOf(filter) >= 0) {
                    return true;
                }
            }
            // check extra fields
            for (var i in config.extra_fields) {
                if (entry[4][i].toLowerCase().indexOf(filter) >= 0) {
                    return true;
                }
            }
            // check value
            if (entry[1].toLowerCase().indexOf(filter) >= 0) {
                return true;
            }
            // check footprint
            if (entry[2].toLowerCase().indexOf(filter) >= 0) {
                return true;
            }
            return false;
        }

        function findRefInEntry(entry) {
            return entry[3].filter(r => r[0].toLowerCase() == reflookup);
        }

        function highlightFilter(s) {
            if (!filter) {
                return s;
            }
            var parts = s.toLowerCase().split(filter);
            if (parts.length == 1) {
                return s;
            }
            var r = "";
            var pos = 0;
            for (var i in parts) {
                if (i > 0) {
                    r += '<mark class="highlight">' +
                        s.substring(pos, pos + filter.length) +
                        '</mark>';
                    pos += filter.length;
                }
                r += s.substring(pos, pos + parts[i].length);
                pos += parts[i].length;
            }
            return r;
        }

        function checkboxSetUnsetAllHandler(checkboxname) {
            return function() {
                var checkboxnum = 0;
                while (checkboxnum < settings.checkboxes.length &&
                    settings.checkboxes[checkboxnum].toLowerCase() != checkboxname.toLowerCase()) {
                    checkboxnum++;
                }
                if (checkboxnum >= settings.checkboxes.length) {
                    return;
                }
                var allset = true;
                var checkbox;
                var row;
                for (row of bombody.childNodes) {
                    checkbox = row.childNodes[checkboxnum + 1].childNodes[0];
                    if (!checkbox.checked || checkbox.indeterminate) {
                        allset = false;
                        break;
                    }
                }
                for (row of bombody.childNodes) {
                    checkbox = row.childNodes[checkboxnum + 1].childNodes[0];
                    checkbox.checked = !allset;
                    checkbox.indeterminate = false;
                    checkbox.onchange();
                }
            }
        }

        function createColumnHeader(name, cls, comparator) {
            var th = document.createElement("TH");
            th.innerHTML = name;
            th.classList.add(cls);
            th.style.cursor = "pointer";
            var span = document.createElement("SPAN");
            span.classList.add("sortmark");
            span.classList.add("none");
            th.appendChild(span);
            th.onclick = function() {
                if (currentSortColumn && this !== currentSortColumn) {
                    // Currently sorted by another column
                    currentSortColumn.childNodes[1].classList.remove(currentSortOrder);
                    currentSortColumn.childNodes[1].classList.add("none");
                    currentSortColumn = null;
                    currentSortOrder = null;
                }
                if (currentSortColumn && this === currentSortColumn) {
                    // Already sorted by this column
                    if (currentSortOrder == "asc") {
                        // Sort by this column, descending order
                        bomSortFunction = function(a, b) {
                            return -comparator(a, b);
                        }
                        currentSortColumn.childNodes[1].classList.remove("asc");
                        currentSortColumn.childNodes[1].classList.add("desc");
                        currentSortOrder = "desc";
                    } else {
                        // Unsort
                        bomSortFunction = null;
                        currentSortColumn.childNodes[1].classList.remove("desc");
                        currentSortColumn.childNodes[1].classList.add("none");
                        currentSortColumn = null;
                        currentSortOrder = null;
                    }
                } else {
                    // Sort by this column, ascending order
                    bomSortFunction = comparator;
                    currentSortColumn = this;
                    currentSortColumn.childNodes[1].classList.remove("none");
                    currentSortColumn.childNodes[1].classList.add("asc");
                    currentSortOrder = "asc";
                }
                populateBomBody();
            }
            return th;
        }

        function populateBomHeader() {
            while (bomhead.firstChild) {
                bomhead.removeChild(bomhead.firstChild);
            }
            var tr = document.createElement("TR");
            var th = document.createElement("TH");
            th.classList.add("numCol");
            tr.appendChild(th);
            var checkboxCompareClosure = function(checkbox) {
                return (a, b) => {
                    var stateA = getCheckboxState(checkbox, a[3]);
                    var stateB = getCheckboxState(checkbox, b[3]);
                    if (stateA > stateB) return -1;
                    if (stateA < stateB) return 1;
                    return 0;
                }
            }
            if (settings.bommode == "netlist") {
                th = createColumnHeader("Net name", "bom-netname", (a, b) => {
                    if (a > b) return -1;
                    if (a < b) return 1;
                    return 0;
                });
                tr.appendChild(th);
            } else {
                for (var checkbox of settings.checkboxes) {
                    th = createColumnHeader(
                        checkbox, "bom-checkbox", checkboxCompareClosure(checkbox));
                    th.onclick = fancyDblClickHandler(
                        th, th.onclick.bind(th), checkboxSetUnsetAllHandler(checkbox));
                    tr.appendChild(th);
                }
                tr.appendChild(createColumnHeader("References", "References", (a, b) => {
                    var i = 0;
                    while (i < a[3].length && i < b[3].length) {
                        if (a[3][i] != b[3][i]) return a[3][i] > b[3][i] ? 1 : -1;
                        i++;
                    }
                    return a[3].length - b[3].length;
                }));
                // Extra fields
                if (config.extra_fields.length > 0) {
                    var extraFieldCompareClosure = function(fieldIndex) {
                        return (a, b) => {
                            var fa = a[4][fieldIndex];
                            var fb = b[4][fieldIndex];
                            if (fa != fb) return fa > fb ? 1 : -1;
                            else return 0;
                        }
                    }
                    for (var i in config.extra_fields) {
                        tr.appendChild(createColumnHeader(
                            config.extra_fields[i], "extra", extraFieldCompareClosure(i)));
                    }
                }
                tr.appendChild(createColumnHeader("Value", "Value", (a, b) => {
                    return valueCompare(a[5], b[5], a[1], b[1]);
                }));
                tr.appendChild(createColumnHeader("Footprint", "Footprint", (a, b) => {
                    if (a[2] != b[2]) return a[2] > b[2] ? 1 : -1;
                    else return 0;
                }));
                if (settings.bommode == "grouped") {
                    tr.appendChild(createColumnHeader("Quantity", "Quantity", (a, b) => {
                        return a[3].length - b[3].length;
                    }));
                }
            }
            bomhead.appendChild(tr);
        }

        function populateBomBody() {
            while (bom.firstChild) {
                bom.removeChild(bom.firstChild);
            }
            highlightHandlers = [];
            footprintIndexToHandler = {};
            netsToHandler = {};
            currentHighlightedRowId = null;
            var first = true;
            if (settings.bommode == "netlist") {
                bomtable = pcbdata.nets.slice();
            } else {
                switch (settings.canvaslayout) {
                    case 'F':
                        bomtable = pcbdata.bom.F.slice();
                        break;
                    case 'FB':
                        bomtable = pcbdata.bom.both.slice();
                        break;
                    case 'B':
                        bomtable = pcbdata.bom.B.slice();
                        break;
                }
                if (settings.bommode == "ungrouped") {
                    // expand bom table
                    expandedTable = []
                    for (var bomentry of bomtable) {
                        for (var ref of bomentry[3]) {
                            expandedTable.push([1, bomentry[1], bomentry[2],
                                [ref], bomentry[4], bomentry[5]
                            ]);
                        }
                    }
                    bomtable = expandedTable;
                }
            }
            if (bomSortFunction) {
                bomtable = bomtable.sort(bomSortFunction);
            }
            for (var i in bomtable) {
                var bomentry = bomtable[i];
                if (filter && !entryMatches(bomentry)) {
                    continue;
                }
                var references = null;
                var netname = null;
                var tr = document.createElement("TR");
                var td = document.createElement("TD");
                var rownum = +i + 1;
                tr.id = "bomrow" + rownum;
                td.textContent = rownum;
                tr.appendChild(td);
                if (settings.bommode == "netlist") {
                    netname = bomentry;
                    td = document.createElement("TD");
                    td.innerHTML = highlightFilter(netname ? netname : "&lt;no net&gt;");
                    tr.appendChild(td);
                } else {
                    if (reflookup) {
                        references = findRefInEntry(bomentry);
                        if (references.length == 0) {
                            continue;
                        }
                    } else {
                        references = bomentry[3];
                    }
                    // Checkboxes
                    for (var checkbox of settings.checkboxes) {
                        if (checkbox) {
                            td = document.createElement("TD");
                            var input = document.createElement("input");
                            input.type = "checkbox";
                            input.onchange = createCheckboxChangeHandler(checkbox, references, tr);
                            setBomCheckboxState(checkbox, input, references);
                            if (input.checked && settings.darkenWhenChecked == checkbox) {
                                tr.classList.add("checked");
                            }
                            td.appendChild(input);
                            tr.appendChild(td);
                        }
                    }
                    // References
                    td = document.createElement("TD");
                    td.innerHTML = highlightFilter(references.map(r => r[0]).join(", "));
                    tr.appendChild(td);
                    // Extra fields
                    for (var i in config.extra_fields) {
                        td = document.createElement("TD");
                        td.innerHTML = highlightFilter(bomentry[4][i]);
                        tr.appendChild(td);
                    }
                    // Value
                    td = document.createElement("TD");
                    td.innerHTML = highlightFilter(bomentry[1]);
                    tr.appendChild(td);
                    // Footprint
                    td = document.createElement("TD");
                    td.innerHTML = highlightFilter(bomentry[2]);
                    tr.appendChild(td);
                    if (settings.bommode == "grouped") {
                        // Quantity
                        td = document.createElement("TD");
                        td.textContent = bomentry[3].length;
                        tr.appendChild(td);
                    }
                }
                bom.appendChild(tr);
                var handler = createRowHighlightHandler(tr.id, references, netname);
                tr.onmousemove = handler;
                highlightHandlers.push({
                    id: tr.id,
                    handler: handler,
                });
                if (references !== null) {
                    for (var refIndex of references.map(r => r[1])) {
                        footprintIndexToHandler[refIndex] = handler;
                    }
                }
                if (netname !== null) {
                    netsToHandler[netname] = handler;
                }
                if ((filter || reflookup) && first) {
                    handler();
                    first = false;
                }
            }
            EventHandler.emitEvent(
                IBOM_EVENT_TYPES.BOM_BODY_CHANGE_EVENT, {
                    filter: filter,
                    reflookup: reflookup,
                    checkboxes: settings.checkboxes,
                    bommode: settings.bommode,
                });
        }

        function highlightPreviousRow() {
            if (!currentHighlightedRowId) {
                highlightHandlers[highlightHandlers.length - 1].handler();
            } else {
                if (highlightHandlers.length > 1 &&
                    highlightHandlers[0].id == currentHighlightedRowId) {
                    highlightHandlers[highlightHandlers.length - 1].handler();
                } else {
                    for (var i = 0; i < highlightHandlers.length - 1; i++) {
                        if (highlightHandlers[i + 1].id == currentHighlightedRowId) {
                            highlightHandlers[i].handler();
                            break;
                        }
                    }
                }
            }
            smoothScrollToRow(currentHighlightedRowId);
        }

        function highlightNextRow() {
            if (!currentHighlightedRowId) {
                highlightHandlers[0].handler();
            } else {
                if (highlightHandlers.length > 1 &&
                    highlightHandlers[highlightHandlers.length - 1].id == currentHighlightedRowId) {
                    highlightHandlers[0].handler();
                } else {
                    for (var i = 1; i < highlightHandlers.length; i++) {
                        if (highlightHandlers[i - 1].id == currentHighlightedRowId) {
                            highlightHandlers[i].handler();
                            break;
                        }
                    }
                }
            }
            smoothScrollToRow(currentHighlightedRowId);
        }

        function populateBomTable() {
            populateBomHeader();
            populateBomBody();
        }

        function footprintsClicked(footprintIndexes) {
            var lastClickedIndex = footprintIndexes.indexOf(lastClicked);
            for (var i = 1; i <= footprintIndexes.length; i++) {
                var refIndex = footprintIndexes[(lastClickedIndex + i) % footprintIndexes.length];
                if (refIndex in footprintIndexToHandler) {
                    lastClicked = refIndex;
                    footprintIndexToHandler[refIndex]();
                    smoothScrollToRow(currentHighlightedRowId);
                    break;
                }
            }
        }

        function netClicked(net) {
            if (net in netsToHandler) {
                netsToHandler[net]();
                smoothScrollToRow(currentHighlightedRowId);
            } else {
                clearHighlightedFootprints();
                highlightedNet = net;
                drawHighlights();
            }
        }

        function updateFilter(input) {
            filter = input.toLowerCase();
            populateBomTable();
        }

        function updateRefLookup(input) {
            reflookup = input.toLowerCase();
            populateBomTable();
        }

        function changeCanvasLayout(layout) {
            document.getElementById("fl-btn").classList.remove("depressed");
            document.getElementById("fb-btn").classList.remove("depressed");
            document.getElementById("bl-btn").classList.remove("depressed");
            switch (layout) {
                case 'F':
                    document.getElementById("fl-btn").classList.add("depressed");
                    if (settings.bomlayout != "bom-only") {
                        canvassplit.collapse(1);
                    }
                    break;
                case 'B':
                    document.getElementById("bl-btn").classList.add("depressed");
                    if (settings.bomlayout != "bom-only") {
                        canvassplit.collapse(0);
                    }
                    break;
                default:
                    document.getElementById("fb-btn").classList.add("depressed");
                    if (settings.bomlayout != "bom-only") {
                        canvassplit.setSizes([50, 50]);
                    }
            }
            settings.canvaslayout = layout;
            writeStorage("canvaslayout", layout);
            resizeAll();
            changeBomMode(settings.bommode);
        }

        function populateMetadata() {
            document.getElementById("title").innerHTML = pcbdata.metadata.title;
            document.getElementById("revision").innerHTML = "Rev: " + pcbdata.metadata.revision;
            document.getElementById("company").innerHTML = pcbdata.metadata.company;
            document.getElementById("filedate").innerHTML = pcbdata.metadata.date;
            if (pcbdata.metadata.title != "") {
                document.title = pcbdata.metadata.title + " BOM";
            }
            // Calculate board stats
            var fp_f = 0,
                fp_b = 0,
                pads_f = 0,
                pads_b = 0,
                pads_th = 0;
            for (var i = 0; i < pcbdata.footprints.length; i++) {
                if (pcbdata.bom.skipped.includes(i)) continue;
                var mod = pcbdata.footprints[i];
                if (mod.layer == "F") {
                    fp_f++;
                } else {
                    fp_b++;
                }
                for (var pad of mod.pads) {
                    if (pad.type == "th") {
                        pads_th++;
                    } else {
                        if (pad.layers.includes("F")) {
                            pads_f++;
                        }
                        if (pad.layers.includes("B")) {
                            pads_b++;
                        }
                    }
                }
            }
            document.getElementById("stats-components-front").innerHTML = fp_f;
            document.getElementById("stats-components-back").innerHTML = fp_b;
            document.getElementById("stats-components-total").innerHTML = fp_f + fp_b;
            document.getElementById("stats-groups-front").innerHTML = pcbdata.bom.F.length;
            document.getElementById("stats-groups-back").innerHTML = pcbdata.bom.B.length;
            document.getElementById("stats-groups-total").innerHTML = pcbdata.bom.both.length;
            document.getElementById("stats-smd-pads-front").innerHTML = pads_f;
            document.getElementById("stats-smd-pads-back").innerHTML = pads_b;
            document.getElementById("stats-smd-pads-total").innerHTML = pads_f + pads_b;
            document.getElementById("stats-th-pads").innerHTML = pads_th;
            // Update version string
            document.getElementById("github-link").innerHTML = "InteractiveHtmlBom&nbsp;" +
                /^v\d+\.\d+/.exec(pcbdata.ibom_version)[0];
        }

        function changeBomLayout(layout) {
            document.getElementById("bom-btn").classList.remove("depressed");
            document.getElementById("lr-btn").classList.remove("depressed");
            document.getElementById("tb-btn").classList.remove("depressed");
            switch (layout) {
                case 'bom-only':
                    document.getElementById("bom-btn").classList.add("depressed");
                    if (bomsplit) {
                        bomsplit.destroy();
                        bomsplit = null;
                        canvassplit.destroy();
                        canvassplit = null;
                    }
                    document.getElementById("frontcanvas").style.display = "none";
                    document.getElementById("backcanvas").style.display = "none";
                    document.getElementById("bot").style.height = "";
                    break;
                case 'top-bottom':
                    document.getElementById("tb-btn").classList.add("depressed");
                    document.getElementById("frontcanvas").style.display = "";
                    document.getElementById("backcanvas").style.display = "";
                    document.getElementById("bot").style.height = "calc(100% - 80px)";
                    document.getElementById("bomdiv").classList.remove("split-horizontal");
                    document.getElementById("canvasdiv").classList.remove("split-horizontal");
                    document.getElementById("frontcanvas").classList.add("split-horizontal");
                    document.getElementById("backcanvas").classList.add("split-horizontal");
                    if (bomsplit) {
                        bomsplit.destroy();
                        bomsplit = null;
                        canvassplit.destroy();
                        canvassplit = null;
                    }
                    bomsplit = Split(['#bomdiv', '#canvasdiv'], {
                        sizes: [50, 50],
                        onDragEnd: resizeAll,
                        direction: "vertical",
                        gutterSize: 5
                    });
                    canvassplit = Split(['#frontcanvas', '#backcanvas'], {
                        sizes: [50, 50],
                        gutterSize: 5,
                        onDragEnd: resizeAll
                    });
                    break;
                case 'left-right':
                    document.getElementById("lr-btn").classList.add("depressed");
                    document.getElementById("frontcanvas").style.display = "";
                    document.getElementById("backcanvas").style.display = "";
                    document.getElementById("bot").style.height = "calc(100% - 80px)";
                    document.getElementById("bomdiv").classList.add("split-horizontal");
                    document.getElementById("canvasdiv").classList.add("split-horizontal");
                    document.getElementById("frontcanvas").classList.remove("split-horizontal");
                    document.getElementById("backcanvas").classList.remove("split-horizontal");
                    if (bomsplit) {
                        bomsplit.destroy();
                        bomsplit = null;
                        canvassplit.destroy();
                        canvassplit = null;
                    }
                    bomsplit = Split(['#bomdiv', '#canvasdiv'], {
                        sizes: [50, 50],
                        onDragEnd: resizeAll,
                        gutterSize: 5
                    });
                    canvassplit = Split(['#frontcanvas', '#backcanvas'], {
                        sizes: [50, 50],
                        gutterSize: 5,
                        direction: "vertical",
                        onDragEnd: resizeAll
                    });
            }
            settings.bomlayout = layout;
            writeStorage("bomlayout", layout);
            changeCanvasLayout(settings.canvaslayout);
        }

        function changeBomMode(mode) {
            document.getElementById("bom-grouped-btn").classList.remove("depressed");
            document.getElementById("bom-ungrouped-btn").classList.remove("depressed");
            document.getElementById("bom-netlist-btn").classList.remove("depressed");
            switch (mode) {
                case 'grouped':
                    document.getElementById("bom-grouped-btn").classList.add("depressed");
                    break;
                case 'ungrouped':
                    document.getElementById("bom-ungrouped-btn").classList.add("depressed");
                    break;
                case 'netlist':
                    document.getElementById("bom-netlist-btn").classList.add("depressed");
            }
            writeStorage("bommode", mode);
            if (mode != settings.bommode) {
                settings.bommode = mode;
                bomSortFunction = null;
                currentSortColumn = null;
                currentSortOrder = null;
                clearHighlightedFootprints();
            }
            populateBomTable();
        }

        function focusFilterField() {
            focusInputField(document.getElementById("filter"));
        }

        function focusRefLookupField() {
            focusInputField(document.getElementById("reflookup"));
        }

        function toggleBomCheckbox(bomrowid, checkboxnum) {
            if (!bomrowid || checkboxnum > settings.checkboxes.length) {
                return;
            }
            var bomrow = document.getElementById(bomrowid);
            var checkbox = bomrow.childNodes[checkboxnum].childNodes[0];
            checkbox.checked = !checkbox.checked;
            checkbox.indeterminate = false;
            checkbox.onchange();
        }

        function checkBomCheckbox(bomrowid, checkboxname) {
            var checkboxnum = 0;
            while (checkboxnum < settings.checkboxes.length &&
                settings.checkboxes[checkboxnum].toLowerCase() != checkboxname.toLowerCase()) {
                checkboxnum++;
            }
            if (!bomrowid || checkboxnum >= settings.checkboxes.length) {
                return;
            }
            var bomrow = document.getElementById(bomrowid);
            var checkbox = bomrow.childNodes[checkboxnum + 1].childNodes[0];
            checkbox.checked = true;
            checkbox.indeterminate = false;
            checkbox.onchange();
        }

        function setBomCheckboxes(value) {
            writeStorage("bomCheckboxes", value);
            settings.checkboxes = value.split(",").filter((e) => e);
            prepCheckboxes();
            populateBomTable();
            populateDarkenWhenCheckedOptions();
        }

        function setDarkenWhenChecked(value) {
            writeStorage("darkenWhenChecked", value);
            settings.darkenWhenChecked = value;
            populateBomTable();
        }

        function prepCheckboxes() {
            var table = document.getElementById("checkbox-stats");
            while (table.childElementCount > 1) {
                table.removeChild(table.lastChild);
            }
            if (settings.checkboxes.length) {
                table.style.display = "";
            } else {
                table.style.display = "none";
            }
            for (var checkbox of settings.checkboxes) {
                var tr = document.createElement("TR");
                var td = document.createElement("TD");
                td.innerHTML = checkbox;
                tr.appendChild(td);
                td = document.createElement("TD");
                td.id = "checkbox-stats-" + checkbox;
                var progressbar = document.createElement("div");
                progressbar.classList.add("bar");
                td.appendChild(progressbar);
                var text = document.createElement("div");
                text.classList.add("text");
                td.appendChild(text);
                tr.appendChild(td);
                table.appendChild(tr);
                updateCheckboxStats(checkbox);
            }
        }

        function populateDarkenWhenCheckedOptions() {
            var container = document.getElementById("darkenWhenCheckedContainer");

            if (settings.checkboxes.length == 0) {
                container.parentElement.style.display = "none";
                return;
            }

            container.innerHTML = '';
            container.parentElement.style.display = "inline-block";

            function createOption(name, displayName) {
                var id = "darkenWhenChecked-" + name;

                var div = document.createElement("div");
                div.classList.add("radio-container");

                var input = document.createElement("input");
                input.type = "radio";
                input.name = "darkenWhenChecked";
                input.value = name;
                input.id = id;
                input.onchange = () => setDarkenWhenChecked(name);
                div.appendChild(input);

                // Preserve the selected element when the checkboxes change
                if (name == settings.darkenWhenChecked) {
                    input.checked = true;
                }

                var label = document.createElement("label");
                label.innerHTML = displayName;
                label.htmlFor = id;
                div.appendChild(label);

                container.appendChild(div);
            }
            createOption("", "None");
            for (var checkbox of settings.checkboxes) {
                createOption(checkbox, checkbox);
            }
        }

        function updateCheckboxStats(checkbox) {
            var checked = getStoredCheckboxRefs(checkbox).size;
            var total = pcbdata.footprints.length - pcbdata.bom.skipped.length;
            var percent = checked * 100.0 / total;
            var td = document.getElementById("checkbox-stats-" + checkbox);
            td.firstChild.style.width = percent + "%";
            td.lastChild.innerHTML = checked + "/" + total + " (" + Math.round(percent) + "%)";
        }

        document.onkeydown = function(e) {
            switch (e.key) {
                case "n":
                    if (document.activeElement.type == "text") {
                        return;
                    }
                    if (currentHighlightedRowId !== null) {
                        checkBomCheckbox(currentHighlightedRowId, "placed");
                        highlightNextRow();
                        e.preventDefault();
                    }
                    break;
                case "ArrowUp":
                    highlightPreviousRow();
                    e.preventDefault();
                    break;
                case "ArrowDown":
                    highlightNextRow();
                    e.preventDefault();
                    break;
                default:
                    break;
            }
            if (e.altKey) {
                switch (e.key) {
                    case "f":
                        focusFilterField();
                        e.preventDefault();
                        break;
                    case "r":
                        focusRefLookupField();
                        e.preventDefault();
                        break;
                    case "z":
                        changeBomLayout("bom-only");
                        e.preventDefault();
                        break;
                    case "x":
                        changeBomLayout("left-right");
                        e.preventDefault();
                        break;
                    case "c":
                        changeBomLayout("top-bottom");
                        e.preventDefault();
                        break;
                    case "v":
                        changeCanvasLayout("F");
                        e.preventDefault();
                        break;
                    case "b":
                        changeCanvasLayout("FB");
                        e.preventDefault();
                        break;
                    case "n":
                        changeCanvasLayout("B");
                        e.preventDefault();
                        break;
                    default:
                        break;
                }
                if (e.key >= '1' && e.key <= '9') {
                    toggleBomCheckbox(currentHighlightedRowId, parseInt(e.key));
                }
            }
        }

        function hideNetlistButton() {
            document.getElementById("bom-ungrouped-btn").classList.remove("middle-button");
            document.getElementById("bom-ungrouped-btn").classList.add("right-most-button");
            document.getElementById("bom-netlist-btn").style.display = "none";
        }

        window.onload = function(e) {
            initUtils();
            initRender();
            initStorage();
            initDefaults();
            cleanGutters();
            populateMetadata();
            dbgdiv = document.getElementById("dbg");
            bom = document.getElementById("bombody");
            bomhead = document.getElementById("bomhead");
            filter = "";
            reflookup = "";
            if (!("nets" in pcbdata)) {
                hideNetlistButton();
            }
            initDone = true;
            prepCheckboxes();
            // Triggers render
            changeBomLayout(settings.bomlayout);

            // Users may leave fullscreen without touching the checkbox. Uncheck.
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement)
                    document.getElementById('fullscreenCheckbox').checked = false;
            });
        }

        window.onresize = resizeAll;
        window.matchMedia("print").addListener(resizeAll);

        ///////////////////////////////////////////////

        ///////////////////////////////////////////////

        ///////////////////////////////////////////////
    </script>
</head>

<body>

    <div id="topmostdiv" class="topmostdiv">
        <div id="top">
            <div style="float: right; height: 100%;">
                <div class="hideonprint menu" style="float: right; top: 8px;">
                    <button class="menubtn"></button>
                    <div class="menu-content">
                        <label class="menu-label menu-label-top" style="width: calc(50% - 18px)">
            <input id="darkmodeCheckbox" type="checkbox" onchange="setDarkMode(this.checked)">
            Dark mode
          </label>
                        <!-- This comment eats space! All of it!
          --><label class="menu-label menu-label-top" style="width: calc(50% - 17px); border-left: 0;">
            <input id="fullscreenCheckbox" type="checkbox" onchange="setFullscreen(this.checked)">
            Full Screen
          </label>
                        <label class="menu-label" style="width: calc(50% - 18px)">
            <input id="fabricationCheckbox" type="checkbox" checked onchange="fabricationVisible(this.checked)">
            Fab layer
          </label>
                        <!-- This comment eats space! All of it!
          --><label class="menu-label" style="width: calc(50% - 17px); border-left: 0;">
            <input id="silkscreenCheckbox" type="checkbox" checked onchange="silkscreenVisible(this.checked)">
            Silkscreen
          </label>
                        <label class="menu-label" style="width: calc(50% - 18px)">
            <input id="referencesCheckbox" type="checkbox" checked onchange="referencesVisible(this.checked)">
            References
          </label>
                        <!-- This comment eats space! All of it!
          --><label class="menu-label" style="width: calc(50% - 17px); border-left: 0;">
            <input id="valuesCheckbox" type="checkbox" checked onchange="valuesVisible(this.checked)">
            Values
          </label>
                        <div id="tracksAndZonesCheckboxes">
                            <label class="menu-label" style="width: calc(50% - 18px)">
              <input id="tracksCheckbox" type="checkbox" checked onchange="tracksVisible(this.checked)">
              Tracks
            </label>
                            <!-- This comment eats space! All of it!
            --><label class="menu-label" style="width: calc(50% - 17px); border-left: 0;">
              <input id="zonesCheckbox" type="checkbox" checked onchange="zonesVisible(this.checked)">
              Zones
            </label>
                        </div>
                        <label class="menu-label" style="width: calc(50% - 18px)">
            <input id="padsCheckbox" type="checkbox" checked onchange="padsVisible(this.checked)">
            Pads
          </label>
                        <!-- This comment eats space! All of it!
          --><label class="menu-label" style="width: calc(50% - 17px); border-left: 0;">
            <input id="dnpOutlineCheckbox" type="checkbox" checked onchange="dnpOutline(this.checked)">
            DNP outlined
          </label>
                        <label class="menu-label">
            <input id="highlightpin1Checkbox" type="checkbox" onchange="setHighlightPin1(this.checked)">
            Highlight first pin
          </label>
                        <label class="menu-label">
            <input id="dragCheckbox" type="checkbox" checked onchange="setRedrawOnDrag(this.checked)">
            Continuous redraw on drag
          </label>
                        <label class="menu-label">
            <span>Board rotation</span>
            <span style="float: right"><span id="rotationDegree">0</span>&#176;</span>
            <input id="boardRotation" type="range" min="-36" max="36" value="0" class="slider" oninput="setBoardRotation(this.value)">
          </label>
                        <label class="menu-label">
            <div style="margin-left: 5px">Bom checkboxes</div>
            <input id="bomCheckboxes" class="menu-textbox" type=text
                   oninput="setBomCheckboxes(this.value)">
          </label>
                        <label class="menu-label">
            <div style="margin-left: 5px">Darken when checked</div>
            <div id="darkenWhenCheckedContainer"></div>
          </label>
                        <label class="menu-label">
            <span class="shameless-plug">
              <span>Created using</span>
              <a id="github-link" target="blank" href="https://github.com/openscopeproject/InteractiveHtmlBom">InteractiveHtmlBom</a>
            </span>
          </label>
                    </div>
                </div>
                <div class="button-container hideonprint" style="float: right; position: relative; top: 8px">
                    <button id="fl-btn" class="left-most-button" onclick="changeCanvasLayout('F')" title="Front only">F
        </button>
                    <button id="fb-btn" class="middle-button" onclick="changeCanvasLayout('FB')" title="Front and Back">FB
        </button>
                    <button id="bl-btn" class="right-most-button" onclick="changeCanvasLayout('B')" title="Back only">B
        </button>
                </div>
                <div class="button-container hideonprint" style="float: right; position: relative; top: 8px">
                    <button id="bom-btn" class="left-most-button" onclick="changeBomLayout('bom-only')" title="BOM only"></button>
                    <button id="lr-btn" class="middle-button" onclick="changeBomLayout('left-right')" title="BOM left, drawings right"></button>
                    <button id="tb-btn" class="right-most-button" onclick="changeBomLayout('top-bottom')" title="BOM top, drawings bot"></button>
                </div>
                <div class="button-container hideonprint" style="float: right; position: relative; top: 8px">
                    <button id="bom-grouped-btn" class="left-most-button" onclick="changeBomMode('grouped')" title="Grouped BOM"></button>
                    <button id="bom-ungrouped-btn" class="middle-button" onclick="changeBomMode('ungrouped')" title="Ungrouped BOM"></button>
                    <button id="bom-netlist-btn" class="right-most-button" onclick="changeBomMode('netlist')" title="Netlist"></button>
                </div>
                <div class="hideonprint menu" style="float: right; top: 8px;">
                    <button class="statsbtn"></button>
                    <div class="menu-content">
                        <table class="stats">
                            <tbody>
                                <tr>
                                    <td width="40%">Board stats</td>
                                    <td>Front</td>
                                    <td>Back</td>
                                    <td>Total</td>
                                </tr>
                                <tr>
                                    <td>Components</td>
                                    <td id="stats-components-front">~</td>
                                    <td id="stats-components-back">~</td>
                                    <td id="stats-components-total">~</td>
                                </tr>
                                <tr>
                                    <td>Groups</td>
                                    <td id="stats-groups-front">~</td>
                                    <td id="stats-groups-back">~</td>
                                    <td id="stats-groups-total">~</td>
                                </tr>
                                <tr>
                                    <td>SMD pads</td>
                                    <td id="stats-smd-pads-front">~</td>
                                    <td id="stats-smd-pads-back">~</td>
                                    <td id="stats-smd-pads-total">~</td>
                                </tr>
                                <tr>
                                    <td>TH pads</td>
                                    <td colspan=3 id="stats-th-pads">~</td>
                                </tr>
                            </tbody>
                        </table>
                        <table class="stats">
                            <col width="40%" />
                            <col />
                            <tbody id="checkbox-stats">
                                <tr>
                                    <td colspan=2 style="border-top: 0">Checkboxes</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="hideonprint menu" style="float: right; top: 8px;">
                    <button class="iobtn"></button>
                    <div class="menu-content">
                        <div class="menu-label menu-label-top">
                            <div style="margin-left: 5px;">Save board image</div>
                            <div class="flexbox">
                                <input id="render-save-width" class="menu-textbox" type="text" value="1000" placeholder="Width" style="flex-grow: 1; width: 50px;" oninput="validateSaveImgDimension(this)">
                                <span>X</span>
                                <input id="render-save-height" class="menu-textbox" type="text" value="1000" placeholder="Height" style="flex-grow: 1; width: 50px;" oninput="validateSaveImgDimension(this)">
                            </div>
                            <label>
              <input id="render-save-transparent" type="checkbox">
              Transparent background
            </label>
                            <div class="flexbox">
                                <button class="savebtn" onclick="saveImage('F')">Front</button>
                                <button class="savebtn" onclick="saveImage('B')">Back</button>
                            </div>
                        </div>
                        <div class="menu-label">
                            <span style="margin-left: 5px;">Config and checkbox state</span>
                            <div class="flexbox">
                                <button class="savebtn" onclick="saveSettings()">Export</button>
                                <button class="savebtn" onclick="loadSettings()">Import</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="fileinfodiv" style="overflow: auto;">
                <table class="fileinfo">
                    <tbody>
                        <tr>
                            <td id="title" class="title" style="width: 70%">
                                Title
                            </td>
                            <td id="revision" class="title" style="width: 30%">
                                Revision
                            </td>
                        </tr>
                        <tr>
                            <td id="company">
                                Company
                            </td>
                            <td id="filedate">
                                Date
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div id="bot" class="split" style="height: calc(100% - 80px)">
            <div id="bomdiv" class="split split-horizontal">
                <div style="width: 100%">
                    <input id="reflookup" class="textbox searchbox reflookup hideonprint" type="text" placeholder="Ref lookup" oninput="updateRefLookup(this.value)">
                    <input id="filter" class="textbox searchbox filter hideonprint" type="text" placeholder="Filter" oninput="updateFilter(this.value)">
                    <div class="button-container hideonprint" style="float: left; margin: 0;">
                        <button id="copy" title="Copy bom table to clipboard" onclick="copyToClipboard()"></button>
                    </div>
                </div>
                <div id="dbg"></div>
                <table class="bom">
                    <thead id="bomhead">
                    </thead>
                    <tbody id="bombody">
                    </tbody>
                </table>
            </div>
            <div id="canvasdiv" class="split split-horizontal">
                <div id="frontcanvas" class="split" touch-action="none" style="overflow: hidden">
                    <div style="position: relative; width: 100%; height: 100%;">
                        <canvas id="F_bg" style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
                        <canvas id="F_fab" style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
                        <canvas id="F_slk" style="position: absolute; left: 0; top: 0; z-index: 2;"></canvas>
                        <canvas id="F_hl" style="position: absolute; left: 0; top: 0; z-index: 3;"></canvas>
                    </div>
                </div>
                <div id="backcanvas" class="split" touch-action="none" style="overflow: hidden">
                    <div style="position: relative; width: 100%; height: 100%;">
                        <canvas id="B_bg" style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
                        <canvas id="B_fab" style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
                        <canvas id="B_slk" style="position: absolute; left: 0; top: 0; z-index: 2;"></canvas>
                        <canvas id="B_hl" style="position: absolute; left: 0; top: 0; z-index: 3;"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

</body>

</html>